In file included from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/planning/phase.h:27:60: error: ‘template<class PHASE> using pos_t = typename PHASE::pos_t’ redeclared as different kind of symbol
  template <class PHASE> using pos_t = typename PHASE::pos_t;
                                                            ^
In file included from /home/mirmik/project/ralgo/./ralgo/planning/phase.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/defs.h:6:16: note: previous declaration ‘typedef float ralgo::pos_t’
  typedef float pos_t;
                ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/planning/phase.h:28:60: error: ‘template<class PHASE> using spd_t = typename PHASE::spd_t’ redeclared as different kind of symbol
  template <class PHASE> using spd_t = typename PHASE::spd_t;
                                                            ^
In file included from /home/mirmik/project/ralgo/./ralgo/planning/phase.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/defs.h:7:16: note: previous declaration ‘typedef float ralgo::spd_t’
  typedef float spd_t;
                ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/planning/phase.h:29:60: error: ‘template<class PHASE> using acc_t = typename PHASE::acc_t’ redeclared as different kind of symbol
  template <class PHASE> using acc_t = typename PHASE::acc_t;
                                                            ^
In file included from /home/mirmik/project/ralgo/./ralgo/planning/phase.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/home/mirmik/project/ralgo/./ralgo/defs.h:8:16: note: previous declaration ‘typedef float ralgo::acc_t’
  typedef float acc_t;
                ^~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:84:30: error: ‘converter’ is not a class template
     template<class T> struct converter<mat<T,1,1>, identity_t> { mat<T,1,1> operator() (identity_t) const { return {vec<T,1>{1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:84:40: error: ‘mat’ was not declared in this scope
     template<class T> struct converter<mat<T,1,1>, identity_t> { mat<T,1,1> operator() (identity_t) const { return {vec<T,1>{1}}; } };
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:84:40: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
/usr/local/include/linalg-v3/linalg.h:84:30: error: ‘struct linalg::converter’ redeclared as different kind of symbol
     template<class T> struct converter<mat<T,1,1>, identity_t> { mat<T,1,1> operator() (identity_t) const { return {vec<T,1>{1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:80:39: note: previous declaration ‘template<class T, class U> struct linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:85:30: error: ‘converter’ is not a class template
     template<class T> struct converter<mat<T,2,2>, identity_t> { mat<T,2,2> operator() (identity_t) const { return {{1,0},{0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:85:40: error: ‘mat’ was not declared in this scope
     template<class T> struct converter<mat<T,2,2>, identity_t> { mat<T,2,2> operator() (identity_t) const { return {{1,0},{0,1}}; } };
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:85:40: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
/usr/local/include/linalg-v3/linalg.h:85:30: error: ‘struct linalg::converter’ redeclared as different kind of symbol
     template<class T> struct converter<mat<T,2,2>, identity_t> { mat<T,2,2> operator() (identity_t) const { return {{1,0},{0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:80:39: note: previous declaration ‘template<class T, class U> struct linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:86:30: error: ‘converter’ is not a class template
     template<class T> struct converter<mat<T,3,3>, identity_t> { mat<T,3,3> operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:86:40: error: ‘mat’ was not declared in this scope
     template<class T> struct converter<mat<T,3,3>, identity_t> { mat<T,3,3> operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:86:40: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
/usr/local/include/linalg-v3/linalg.h:86:30: error: ‘struct linalg::converter’ redeclared as different kind of symbol
     template<class T> struct converter<mat<T,3,3>, identity_t> { mat<T,3,3> operator() (identity_t) const { return {{1,0,0},{0,1,0},{0,0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:80:39: note: previous declaration ‘template<class T, class U> struct linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:87:30: error: ‘converter’ is not a class template
     template<class T> struct converter<mat<T,4,4>, identity_t> { mat<T,4,4> operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:87:40: error: ‘mat’ was not declared in this scope
     template<class T> struct converter<mat<T,4,4>, identity_t> { mat<T,4,4> operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:87:40: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
/usr/local/include/linalg-v3/linalg.h:87:30: error: ‘struct linalg::converter’ redeclared as different kind of symbol
     template<class T> struct converter<mat<T,4,4>, identity_t> { mat<T,4,4> operator() (identity_t) const { return {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1}}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:80:39: note: previous declaration ‘template<class T, class U> struct linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:88:30: error: ‘converter’ is not a class template
     template<class T> struct converter<quat<T>, identity_t> { quat<T> operator() (identity_t) const { return {0,0,0,1}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:88:40: error: ‘quat’ was not declared in this scope
     template<class T> struct converter<quat<T>, identity_t> { quat<T> operator() (identity_t) const { return {0,0,0,1}; } };
                                        ^~~~
/usr/local/include/linalg-v3/linalg.h:88:40: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:77:30: note:   ‘linalg::quat’
     template<class T> struct quat;
                              ^~~~
/usr/local/include/linalg-v3/linalg.h:88:30: error: ‘struct linalg::converter’ redeclared as different kind of symbol
     template<class T> struct converter<quat<T>, identity_t> { quat<T> operator() (identity_t) const { return {0,0,0,1}; } };
                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:80:39: note: previous declaration ‘template<class T, class U> struct linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:89:15: error: ‘identity_t’ does not name a type
     constexpr identity_t identity {1};
               ^~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:105:111: error: ‘converter’ was not declared in this scope
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:105:111: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:80:39: note:   ‘linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:105:111: error: ‘converter’ was not declared in this scope
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:105:111: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:80:39: note:   ‘linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:105:122: error: expected primary-expression before ‘,’ token
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h:105:124: error: expected primary-expression before ‘>’ token
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h:105:126: error: expected primary-expression before ‘)’ token
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                                              ^
/usr/local/include/linalg-v3/linalg.h:105:147: error: template argument 2 is invalid
         template<class T, class U> using conv_t = typename std::enable_if<!std::is_same<T,U>::value, decltype(converter<T,U>()(std::declval<U>()))>::type;
                                                                                                                                                   ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::convert(const U&)’:
/usr/local/include/linalg-v3/linalg.h:106:78: error: ‘converter’ was not declared in this scope
         template<class T, class U> constexpr T convert(const U & u) { return converter<T,U>()(u); }
                                                                              ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:106:78: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:80:39: note:   ‘linalg::converter’
     template<class T, class U> struct converter {};
                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:106:89: error: expected primary-expression before ‘,’ token
         template<class T, class U> constexpr T convert(const U & u) { return converter<T,U>()(u); }
                                                                                         ^
/usr/local/include/linalg-v3/linalg.h:106:91: error: expected primary-expression before ‘>’ token
         template<class T, class U> constexpr T convert(const U & u) { return converter<T,U>()(u); }
                                                                                           ^
/usr/local/include/linalg-v3/linalg.h:106:93: error: expected primary-expression before ‘)’ token
         template<class T, class U> constexpr T convert(const U & u) { return converter<T,U>()(u); }
                                                                                             ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:110:50: error: ‘unpack’ is not a class template
         template<class T, class A, int I> struct unpack<_scalar<T,A,I>> { using type=T; };
                                                  ^~~~~~
/usr/local/include/linalg-v3/linalg.h:110:57: error: ‘_scalar’ was not declared in this scope
         template<class T, class A, int I> struct unpack<_scalar<T,A,I>> { using type=T; };
                                                         ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:110:57: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:96:46: note:   ‘linalg::_scalar’
     template<class T, class A, int I> struct _scalar;
                                              ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:110:50: error: ‘struct linalg::detail::unpack’ redeclared as different kind of symbol
         template<class T, class A, int I> struct unpack<_scalar<T,A,I>> { using type=T; };
                                                  ^~~~~~
/usr/local/include/linalg-v3/linalg.h:109:34: note: previous declaration ‘template<class T> struct linalg::detail::unpack’
         template<class T> struct unpack { using type=T; };
                                  ^~~~~~
/usr/local/include/linalg-v3/linalg.h:110:70: error: expected unqualified-id before ‘>’ token
         template<class T, class A, int I> struct unpack<_scalar<T,A,I>> { using type=T; };
                                                                      ^~
/usr/local/include/linalg-v3/linalg.h:111:53: error: ‘unpack’ is not a class template
         template<class T, class A, int... I> struct unpack<_lswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                     ^~~~~~
/usr/local/include/linalg-v3/linalg.h:111:60: error: ‘_lswizzle’ was not declared in this scope
         template<class T, class A, int... I> struct unpack<_lswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                            ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:111:60: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:97:49: note:   ‘linalg::_lswizzle’
     template<class T, class A, int... I> struct _lswizzle;
                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:111:75: error: expected parameter pack before ‘...’
         template<class T, class A, int... I> struct unpack<_lswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                                           ^~~
/usr/local/include/linalg-v3/linalg.h:111:53: error: ‘struct linalg::detail::unpack’ redeclared as different kind of symbol
         template<class T, class A, int... I> struct unpack<_lswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                     ^~~~~~
/usr/local/include/linalg-v3/linalg.h:109:34: note: previous declaration ‘template<class T> struct linalg::detail::unpack’
         template<class T> struct unpack { using type=T; };
                                  ^~~~~~
/usr/local/include/linalg-v3/linalg.h:111:78: error: expected unqualified-id before ‘>’ token
         template<class T, class A, int... I> struct unpack<_lswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                                              ^~
/usr/local/include/linalg-v3/linalg.h:112:53: error: ‘unpack’ is not a class template
         template<class T, class A, int... I> struct unpack<_rswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                     ^~~~~~
/usr/local/include/linalg-v3/linalg.h:112:60: error: ‘_rswizzle’ was not declared in this scope
         template<class T, class A, int... I> struct unpack<_rswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                            ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:112:60: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:98:49: note:   ‘linalg::_rswizzle’
     template<class T, class A, int... I> struct _rswizzle;
                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:112:75: error: expected parameter pack before ‘...’
         template<class T, class A, int... I> struct unpack<_rswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                                           ^~~
/usr/local/include/linalg-v3/linalg.h:112:53: error: ‘struct linalg::detail::unpack’ redeclared as different kind of symbol
         template<class T, class A, int... I> struct unpack<_rswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                     ^~~~~~
/usr/local/include/linalg-v3/linalg.h:109:34: note: previous declaration ‘template<class T> struct linalg::detail::unpack’
         template<class T> struct unpack { using type=T; };
                                  ^~~~~~
/usr/local/include/linalg-v3/linalg.h:112:78: error: expected unqualified-id before ‘>’ token
         template<class T, class A, int... I> struct unpack<_rswizzle<T,A,I...>> { using type=vec<T,sizeof...(I)>; };
                                                                              ^~
/usr/local/include/linalg-v3/linalg.h:113:53: error: expected nested-name-specifier before ‘unpack’
         template<class T> using unpack_t = typename unpack<T>::type;
                                                     ^~~~~~
/usr/local/include/linalg-v3/linalg.h:117:61: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator == (const ord<T> & o, std::nullptr_t) { return o.a == o.b; }
                                                             ^~~
/usr/local/include/linalg-v3/linalg.h:117:64: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator == (const ord<T> & o, std::nullptr_t) { return o.a == o.b; }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:117:87: error: ‘constexpr bool ralgo::operator==(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator == (const ord<T> & o, std::nullptr_t) { return o.a == o.b; }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:118:61: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator != (const ord<T> & o, std::nullptr_t) { return !(o.a == o.b); }
                                                             ^~~
/usr/local/include/linalg-v3/linalg.h:118:64: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator != (const ord<T> & o, std::nullptr_t) { return !(o.a == o.b); }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:118:87: error: ‘constexpr bool ralgo::operator!=(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator != (const ord<T> & o, std::nullptr_t) { return !(o.a == o.b); }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:119:60: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator < (const ord<T> & o, std::nullptr_t) { return o.a < o.b; }
                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:119:63: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator < (const ord<T> & o, std::nullptr_t) { return o.a < o.b; }
                                                               ^
/usr/local/include/linalg-v3/linalg.h:119:86: error: ‘constexpr bool ralgo::operator<(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator < (const ord<T> & o, std::nullptr_t) { return o.a < o.b; }
                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:120:60: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator > (const ord<T> & o, std::nullptr_t) { return o.b < o.a; }
                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:120:63: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator > (const ord<T> & o, std::nullptr_t) { return o.b < o.a; }
                                                               ^
/usr/local/include/linalg-v3/linalg.h:120:86: error: ‘constexpr bool ralgo::operator>(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator > (const ord<T> & o, std::nullptr_t) { return o.b < o.a; }
                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:121:61: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator <= (const ord<T> & o, std::nullptr_t) { return !(o.b < o.a); }
                                                             ^~~
/usr/local/include/linalg-v3/linalg.h:121:64: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator <= (const ord<T> & o, std::nullptr_t) { return !(o.b < o.a); }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:121:87: error: ‘constexpr bool ralgo::operator<=(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator <= (const ord<T> & o, std::nullptr_t) { return !(o.b < o.a); }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:122:61: error: ‘ord’ does not name a type
         template<class T> constexpr bool operator >= (const ord<T> & o, std::nullptr_t) { return !(o.a < o.b); }
                                                             ^~~
/usr/local/include/linalg-v3/linalg.h:122:64: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class T> constexpr bool operator >= (const ord<T> & o, std::nullptr_t) { return !(o.a < o.b); }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:122:87: error: ‘constexpr bool ralgo::operator>=(int)’ must have an argument of class or enumerated type
         template<class T> constexpr bool operator >= (const ord<T> & o, std::nullptr_t) { return !(o.a < o.b); }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:126:34: error: ‘any_compare’ is not a class template
         template<class T> struct any_compare<vec<T,1>,vec<T,1>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,1> & a, const vec<T,1> & b) const { return ord<T>{a[0],b[0]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:126:46: error: ‘vec’ was not declared in this scope
         template<class T> struct any_compare<vec<T,1>,vec<T,1>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,1> & a, const vec<T,1> & b) const { return ord<T>{a[0],b[0]}; } };
                                              ^~~
/usr/local/include/linalg-v3/linalg.h:126:46: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:126:34: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T> struct any_compare<vec<T,1>,vec<T,1>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,1> & a, const vec<T,1> & b) const { return ord<T>{a[0],b[0]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:127:34: error: ‘any_compare’ is not a class template
         template<class T> struct any_compare<vec<T,2>,vec<T,2>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,2> & a, const vec<T,2> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : ord<T>{a[1],b[1]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:127:46: error: ‘vec’ was not declared in this scope
         template<class T> struct any_compare<vec<T,2>,vec<T,2>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,2> & a, const vec<T,2> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : ord<T>{a[1],b[1]}; } };
                                              ^~~
/usr/local/include/linalg-v3/linalg.h:127:46: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:127:34: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T> struct any_compare<vec<T,2>,vec<T,2>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,2> & a, const vec<T,2> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : ord<T>{a[1],b[1]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:128:34: error: ‘any_compare’ is not a class template
         template<class T> struct any_compare<vec<T,3>,vec<T,3>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,3> & a, const vec<T,3> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : ord<T>{a[2],b[2]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:128:46: error: ‘vec’ was not declared in this scope
         template<class T> struct any_compare<vec<T,3>,vec<T,3>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,3> & a, const vec<T,3> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : ord<T>{a[2],b[2]}; } };
                                              ^~~
/usr/local/include/linalg-v3/linalg.h:128:46: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:128:34: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T> struct any_compare<vec<T,3>,vec<T,3>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,3> & a, const vec<T,3> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : ord<T>{a[2],b[2]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:129:34: error: ‘any_compare’ is not a class template
         template<class T> struct any_compare<vec<T,4>,vec<T,4>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,4> & a, const vec<T,4> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : !(a[2]==b[2]) ? ord<T>{a[2],b[2]} : ord<T>{a[3],b[3]}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:129:46: error: ‘vec’ was not declared in this scope
         template<class T> struct any_compare<vec<T,4>,vec<T,4>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,4> & a, const vec<T,4> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : !(a[2]==b[2]) ? ord<T>{a[2],b[2]} : ord<T>{a[3],b[3]}; } };
                                              ^~~
/usr/local/include/linalg-v3/linalg.h:129:46: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:129:34: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T> struct any_compare<vec<T,4>,vec<T,4>> { using type=ord<T>; constexpr ord<T> operator() (const vec<T,4> & a, const vec<T,4> & b) const { return !(a[0]==b[0]) ? ord<T>{a[0],b[0]} : !(a[1]==b[1]) ? ord<T>{a[1],b[1]} : !(a[2]==b[2]) ? ord<T>{a[2],b[2]} : ord<T>{a[3],b[3]}; } };
                                  ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:130:41: error: ‘any_compare’ is not a class template
         template<class T, int M> struct any_compare<mat<T,M,1>,mat<T,M,1>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,1> & a, const mat<T,M,1> & b) const { return compare(a[0],b[0]); } };
                                         ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:130:53: error: ‘mat’ was not declared in this scope
         template<class T, int M> struct any_compare<mat<T,M,1>,mat<T,M,1>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,1> & a, const mat<T,M,1> & b) const { return compare(a[0],b[0]); } };
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:130:53: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:130:41: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T, int M> struct any_compare<mat<T,M,1>,mat<T,M,1>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,1> & a, const mat<T,M,1> & b) const { return compare(a[0],b[0]); } };
                                         ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:131:41: error: ‘any_compare’ is not a class template
         template<class T, int M> struct any_compare<mat<T,M,2>,mat<T,M,2>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,2> & a, const mat<T,M,2> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : compare(a[1],b[1]); } };
                                         ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:131:53: error: ‘mat’ was not declared in this scope
         template<class T, int M> struct any_compare<mat<T,M,2>,mat<T,M,2>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,2> & a, const mat<T,M,2> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : compare(a[1],b[1]); } };
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:131:53: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:131:41: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T, int M> struct any_compare<mat<T,M,2>,mat<T,M,2>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,2> & a, const mat<T,M,2> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : compare(a[1],b[1]); } };
                                         ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:132:41: error: ‘any_compare’ is not a class template
         template<class T, int M> struct any_compare<mat<T,M,3>,mat<T,M,3>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,3> & a, const mat<T,M,3> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : compare(a[2],b[2]); } };
                                         ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:132:53: error: ‘mat’ was not declared in this scope
         template<class T, int M> struct any_compare<mat<T,M,3>,mat<T,M,3>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,3> & a, const mat<T,M,3> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : compare(a[2],b[2]); } };
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:132:53: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:132:41: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T, int M> struct any_compare<mat<T,M,3>,mat<T,M,3>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,3> & a, const mat<T,M,3> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : compare(a[2],b[2]); } };
                                         ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:133:41: error: ‘any_compare’ is not a class template
         template<class T, int M> struct any_compare<mat<T,M,4>,mat<T,M,4>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,4> & a, const mat<T,M,4> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : a[2]!=b[2] ? compare(a[2],b[2]) : compare(a[3],b[3]); } };
                                         ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:133:53: error: ‘mat’ was not declared in this scope
         template<class T, int M> struct any_compare<mat<T,M,4>,mat<T,M,4>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,4> & a, const mat<T,M,4> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : a[2]!=b[2] ? compare(a[2],b[2]) : compare(a[3],b[3]); } };
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:133:53: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note:   ‘linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:133:41: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T, int M> struct any_compare<mat<T,M,4>,mat<T,M,4>> { using type=ord<T>; constexpr ord<T> operator() (const mat<T,M,4> & a, const mat<T,M,4> & b) const { return a[0]!=b[0] ? compare(a[0],b[0]) : a[1]!=b[1] ? compare(a[1],b[1]) : a[2]!=b[2] ? compare(a[2],b[2]) : compare(a[3],b[3]); } };
                                         ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:134:34: error: ‘any_compare’ is not a class template
         template<class T> struct any_compare<quat<T>,quat<T>> { using type=ord<T>; constexpr ord<T> operator() (const quat<T> & a, const quat<T> & b) const { return !(a.x==b.x) ? ord<T>{a.x,b.x} : !(a.y==b.y) ? ord<T>{a.y,b.y} : !(a.z==b.z) ? ord<T>{a.z,b.z} : ord<T>{a.w,b.w}; } };
                                  ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:134:46: error: ‘quat’ was not declared in this scope
         template<class T> struct any_compare<quat<T>,quat<T>> { using type=ord<T>; constexpr ord<T> operator() (const quat<T> & a, const quat<T> & b) const { return !(a.x==b.x) ? ord<T>{a.x,b.x} : !(a.y==b.y) ? ord<T>{a.y,b.y} : !(a.z==b.z) ? ord<T>{a.z,b.z} : ord<T>{a.w,b.w}; } };
                                              ^~~~
/usr/local/include/linalg-v3/linalg.h:134:46: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:77:30: note:   ‘linalg::quat’
     template<class T> struct quat;
                              ^~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:134:34: error: ‘struct linalg::detail::any_compare’ redeclared as different kind of symbol
         template<class T> struct any_compare<quat<T>,quat<T>> { using type=ord<T>; constexpr ord<T> operator() (const quat<T> & a, const quat<T> & b) const { return !(a.x==b.x) ? ord<T>{a.x,b.x} : !(a.y==b.y) ? ord<T>{a.y,b.y} : !(a.z==b.z) ? ord<T>{a.z,b.z} : ord<T>{a.w,b.w}; } };
                                  ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:125:43: note: previous declaration ‘template<class A, class B> struct linalg::detail::any_compare’
         template<class A, class B> struct any_compare {};
                                           ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:139:32: error: ‘make_seq_impl’ is not a class template
         template<int A> struct make_seq_impl<A,0> { using type=seq<>; };
                                ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:139:49: error: conflicting declaration of template ‘template<int A> struct linalg::detail::make_seq_impl’
         template<int A> struct make_seq_impl<A,0> { using type=seq<>; };
                                                 ^
/usr/local/include/linalg-v3/linalg.h:138:39: note: previous declaration ‘template<int A, int N> struct linalg::detail::make_seq_impl’
         template<int A, int N> struct make_seq_impl;
                                       ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:140:32: error: ‘make_seq_impl’ is not a class template
         template<int A> struct make_seq_impl<A,1> { using type=seq<A+0>; };
                                ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:140:49: error: conflicting declaration of template ‘template<int A> struct linalg::detail::make_seq_impl’
         template<int A> struct make_seq_impl<A,1> { using type=seq<A+0>; };
                                                 ^
/usr/local/include/linalg-v3/linalg.h:138:39: note: previous declaration ‘template<int A, int N> struct linalg::detail::make_seq_impl’
         template<int A, int N> struct make_seq_impl;
                                       ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:141:32: error: ‘make_seq_impl’ is not a class template
         template<int A> struct make_seq_impl<A,2> { using type=seq<A+0,A+1>; };
                                ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:141:49: error: conflicting declaration of template ‘template<int A> struct linalg::detail::make_seq_impl’
         template<int A> struct make_seq_impl<A,2> { using type=seq<A+0,A+1>; };
                                                 ^
/usr/local/include/linalg-v3/linalg.h:138:39: note: previous declaration ‘template<int A, int N> struct linalg::detail::make_seq_impl’
         template<int A, int N> struct make_seq_impl;
                                       ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:142:32: error: ‘make_seq_impl’ is not a class template
         template<int A> struct make_seq_impl<A,3> { using type=seq<A+0,A+1,A+2>; };
                                ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:142:49: error: conflicting declaration of template ‘template<int A> struct linalg::detail::make_seq_impl’
         template<int A> struct make_seq_impl<A,3> { using type=seq<A+0,A+1,A+2>; };
                                                 ^
/usr/local/include/linalg-v3/linalg.h:138:39: note: previous declaration ‘template<int A, int N> struct linalg::detail::make_seq_impl’
         template<int A, int N> struct make_seq_impl;
                                       ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:143:32: error: ‘make_seq_impl’ is not a class template
         template<int A> struct make_seq_impl<A,4> { using type=seq<A+0,A+1,A+2,A+3>; };
                                ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:143:49: error: conflicting declaration of template ‘template<int A> struct linalg::detail::make_seq_impl’
         template<int A> struct make_seq_impl<A,4> { using type=seq<A+0,A+1,A+2,A+3>; };
                                                 ^
/usr/local/include/linalg-v3/linalg.h:138:39: note: previous declaration ‘template<int A, int N> struct linalg::detail::make_seq_impl’
         template<int A, int N> struct make_seq_impl;
                                       ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:144:58: error: expected nested-name-specifier before ‘make_seq_impl’
         template<int A, int B> using make_seq = typename make_seq_impl<A,B-A>::type;
                                                          ^~~~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:145:44: error: ‘vec’ does not name a type
         template<class T, int M, int... I> vec<T,sizeof...(I)> constexpr swizzle(const vec<T,M> & v, seq<I...> i) { return {v[I]...}; }
                                            ^~~
/usr/local/include/linalg-v3/linalg.h:146:61: error: ‘mat’ does not name a type
         template<class T, int M, int N, int... I, int... J> mat<T,sizeof...(I),sizeof...(J)> constexpr swizzle(const mat<T,M,N> & m, seq<I...> i, seq<J...> j) { return {swizzle(m[J],i)...}; }
                                                             ^~~
/usr/local/include/linalg-v3/linalg.h:154:27: error: ‘scalars’ is not a class template
         template<> struct scalars<> { using type=void; };
                           ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:154:35: error: ‘struct linalg::detail::scalars’ redeclared as different kind of symbol
         template<> struct scalars<> { using type=void; };
                                   ^
/usr/local/include/linalg-v3/linalg.h:153:37: note: previous declaration ‘template<class ... T> struct linalg::detail::scalars’
         template<class... T> struct scalars;
                                     ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:155:46: error: ‘scalars’ is not a class template
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                              ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:155:60: error: conflicting declaration of template ‘template<class T, class ... U> struct linalg::detail::scalars’
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                                            ^
/usr/local/include/linalg-v3/linalg.h:153:37: note: previous declaration ‘template<class ... T> struct linalg::detail::scalars’
         template<class... T> struct scalars;
                                     ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:155:111: error: ‘scalars’ was not declared in this scope
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                                                                                               ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:155:111: note: suggested alternative:
/usr/local/include/linalg-v3/linalg.h:153:37: note:   ‘linalg::detail::scalars’
         template<class... T> struct scalars;
                                     ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:155:120: error: expected parameter pack before ‘...’
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                                                                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:155:123: error: wrong number of template arguments (2, should be 3)
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                                                                                                           ^
In file included from /usr/include/c++/7/bits/move.h:54:0,
                 from /usr/include/c++/7/bits/stl_pair.h:59,
                 from /usr/include/c++/7/bits/stl_algobase.h:64,
                 from /usr/include/c++/7/bits/char_traits.h:39,
                 from /usr/include/c++/7/string:40,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/type_traits:104:12: note: provided for ‘template<bool <anonymous>, class, class> struct std::conditional’
     struct conditional;
            ^~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:155:131: error: expected class-name before ‘>’ token
         template<class T, class... U> struct scalars<T,U...> : std::conditional<std::is_arithmetic<T>::value, scalars<U...>, empty>::type {};
                                                                                                                                   ^
/usr/local/include/linalg-v3/linalg.h:156:57: error: expected nested-name-specifier before ‘scalars’
         template<class... T> using scalars_t = typename scalars<T...>::type;
                                                         ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:164:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A                  > struct vec_apply<F, scalars_t<   >, vec<A,M>                    > { using type=vec<ret_t<F,A    >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a                                        ) { return {f(a[I]            )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:164:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A                  > struct vec_apply<F, scalars_t<   >, vec<A,M>                    > { using type=vec<ret_t<F,A    >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a                                        ) { return {f(a[I]            )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:164:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A                  > struct vec_apply<F, scalars_t<   >, vec<A,M>                    > { using type=vec<ret_t<F,A    >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a                                        ) { return {f(a[I]            )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:164:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A                  > struct vec_apply<F, scalars_t<   >, vec<A,M>                    > { using type=vec<ret_t<F,A    >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a                                        ) { return {f(a[I]            )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:165:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b                    ) { return {f(a[I], b[I]      )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:165:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b                    ) { return {f(a[I], b[I]      )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:165:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b                    ) { return {f(a[I], b[I]      )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:165:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b                    ) { return {f(a[I], b[I]      )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:166:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<B  >, vec<A,M>, B                 > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b                    ) { return {f(a[I], b         )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:166:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<B  >, vec<A,M>, B                 > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b                    ) { return {f(a[I], b         )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:166:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<B  >, vec<A,M>, B                 > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b                    ) { return {f(a[I], b         )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:166:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<B  >, vec<A,M>, B                 > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b                    ) { return {f(a[I], b         )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:167:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b                    ) { return {f(a,    b[I]      )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:167:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b                    ) { return {f(a,    b[I]      )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:167:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b                    ) { return {f(a,    b[I]      )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:167:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B         > struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>          > { using type=vec<ret_t<F,A,B  >,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b                    ) { return {f(a,    b[I]      )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:168:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a[I], b[I], c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:168:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a[I], b[I], c[I])...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:168:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a[I], b[I], c[I])...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:168:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<   >, vec<A,M>, vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a[I], b[I], c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:169:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<C  >, vec<A,M>, vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, C                c) { return {f(a[I], b[I], c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:169:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<C  >, vec<A,M>, vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, C                c) { return {f(a[I], b[I], c   )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:169:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<C  >, vec<A,M>, vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, C                c) { return {f(a[I], b[I], c   )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:169:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<C  >, vec<A,M>, vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, const vec<B,M> & b, C                c) { return {f(a[I], b[I], c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:170:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B  >, vec<A,M>, B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, const vec<C,M> & c) { return {f(a[I], b,    c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:170:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B  >, vec<A,M>, B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, const vec<C,M> & c) { return {f(a[I], b,    c[I])...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:170:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B  >, vec<A,M>, B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, const vec<C,M> & c) { return {f(a[I], b,    c[I])...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:170:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B  >, vec<A,M>, B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, const vec<C,M> & c) { return {f(a[I], b,    c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:171:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B,C>, vec<A,M>, B,        C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, C                c) { return {f(a[I], b,    c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:171:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B,C>, vec<A,M>, B,        C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, C                c) { return {f(a[I], b,    c   )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:171:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B,C>, vec<A,M>, B,        C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, C                c) { return {f(a[I], b,    c   )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:171:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<B,C>, vec<A,M>, B,        C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, const vec<A,M> & a, B                b, C                c) { return {f(a[I], b,    c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:172:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a,    b[I], c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:172:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a,    b[I], c[I])...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:172:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a,    b[I], c[I])...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:172:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A  >, A,        vec<B,M>, vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, const vec<C,M> & c) { return {f(a,    b[I], c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:173:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,C>, A,        vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, C                c) { return {f(a,    b[I], c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:173:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,C>, A,        vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, C                c) { return {f(a,    b[I], c   )...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:173:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,C>, A,        vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, C                c) { return {f(a,    b[I], c   )...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:173:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,C>, A,        vec<B,M>, C       > { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, const vec<B,M> & b, C                c) { return {f(a,    b[I], c   )...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:174:68: error: ‘vec_apply’ is not a class template
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,B>, A,        B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, B                b, const vec<C,M> & c) { return {f(a,    b,    c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:174:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,B>, A,        B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, B                b, const vec<C,M> & c) { return {f(a,    b,    c[I])...}; } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:174:81: note: suggested alternative: ‘scalars’
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,B>, A,        B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, B                b, const vec<C,M> & c) { return {f(a,    b,    c[I])...}; } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:174:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, int M, class A, class B, class C> struct vec_apply<F, scalars_t<A,B>, A,        B,        vec<C,M>> { using type=vec<ret_t<F,A,B,C>,M>; enum {size=M}; template<int... I> static constexpr type impl(seq<I...>, F f, A                a, B                b, const vec<C,M> & c) { return {f(a,    b,    c[I])...}; } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:176:66: error: ‘axa_apply’ is not a class template
         template<class F, int M, int N, class A         > struct axa_apply<F, scalars_t< >, mat<A,M,N>            > { using type=mat<ret_t<F,A  >,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a                      ) { return {vec_apply<F, void, vec<A,M>          >::impl(make_seq<0,M>{}, f, a[J]      )...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:176:79: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, int N, class A         > struct axa_apply<F, scalars_t< >, mat<A,M,N>            > { using type=mat<ret_t<F,A  >,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a                      ) { return {vec_apply<F, void, vec<A,M>          >::impl(make_seq<0,M>{}, f, a[J]      )...}; } };
                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:176:79: note: suggested alternative: ‘scalars’
         template<class F, int M, int N, class A         > struct axa_apply<F, scalars_t< >, mat<A,M,N>            > { using type=mat<ret_t<F,A  >,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a                      ) { return {vec_apply<F, void, vec<A,M>          >::impl(make_seq<0,M>{}, f, a[J]      )...}; } };
                                                                               ^~~~~~~~~
                                                                               scalars
/usr/local/include/linalg-v3/linalg.h:176:66: error: ‘struct linalg::detail::axa_apply’ redeclared as different kind of symbol
         template<class F, int M, int N, class A         > struct axa_apply<F, scalars_t< >, mat<A,M,N>            > { using type=mat<ret_t<F,A  >,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a                      ) { return {vec_apply<F, void, vec<A,M>          >::impl(make_seq<0,M>{}, f, a[J]      )...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:160:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axa_apply’
         template<class F, class Void, class... T> struct axa_apply {}; // Patterns of the form: algebraic, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:177:66: error: ‘axa_apply’ is not a class template
         template<class F, int M, int N, class A, class B> struct axa_apply<F, scalars_t< >, mat<A,M,N>, mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, const mat<B,M,N> & b) { return {vec_apply<F, void, vec<A,M>, vec<B,M>>::impl(make_seq<0,M>{}, f, a[J], b[J])...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:177:79: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, int N, class A, class B> struct axa_apply<F, scalars_t< >, mat<A,M,N>, mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, const mat<B,M,N> & b) { return {vec_apply<F, void, vec<A,M>, vec<B,M>>::impl(make_seq<0,M>{}, f, a[J], b[J])...}; } };
                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:177:79: note: suggested alternative: ‘scalars’
         template<class F, int M, int N, class A, class B> struct axa_apply<F, scalars_t< >, mat<A,M,N>, mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, const mat<B,M,N> & b) { return {vec_apply<F, void, vec<A,M>, vec<B,M>>::impl(make_seq<0,M>{}, f, a[J], b[J])...}; } };
                                                                               ^~~~~~~~~
                                                                               scalars
/usr/local/include/linalg-v3/linalg.h:177:66: error: ‘struct linalg::detail::axa_apply’ redeclared as different kind of symbol
         template<class F, int M, int N, class A, class B> struct axa_apply<F, scalars_t< >, mat<A,M,N>, mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, const mat<B,M,N> & b) { return {vec_apply<F, void, vec<A,M>, vec<B,M>>::impl(make_seq<0,M>{}, f, a[J], b[J])...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:160:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axa_apply’
         template<class F, class Void, class... T> struct axa_apply {}; // Patterns of the form: algebraic, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:178:66: error: ‘axs_apply’ is not a class template
         template<class F, int M, int N, class A, class B> struct axs_apply<F, scalars_t<B>, mat<A,M,N>, B         > { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, B                  b) { return {vec_apply<F, void, vec<A,M>, B       >::impl(make_seq<0,M>{}, f, a[J], b   )...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:178:79: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, int N, class A, class B> struct axs_apply<F, scalars_t<B>, mat<A,M,N>, B         > { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, B                  b) { return {vec_apply<F, void, vec<A,M>, B       >::impl(make_seq<0,M>{}, f, a[J], b   )...}; } };
                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:178:79: note: suggested alternative: ‘scalars’
         template<class F, int M, int N, class A, class B> struct axs_apply<F, scalars_t<B>, mat<A,M,N>, B         > { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, B                  b) { return {vec_apply<F, void, vec<A,M>, B       >::impl(make_seq<0,M>{}, f, a[J], b   )...}; } };
                                                                               ^~~~~~~~~
                                                                               scalars
/usr/local/include/linalg-v3/linalg.h:178:66: error: ‘struct linalg::detail::axs_apply’ redeclared as different kind of symbol
         template<class F, int M, int N, class A, class B> struct axs_apply<F, scalars_t<B>, mat<A,M,N>, B         > { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, const mat<A,M,N> & a, B                  b) { return {vec_apply<F, void, vec<A,M>, B       >::impl(make_seq<0,M>{}, f, a[J], b   )...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:161:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axs_apply’
         template<class F, class Void, class... T> struct axs_apply {}; // Patterns of the form: algebraic, scalar
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:179:66: error: ‘sxa_apply’ is not a class template
         template<class F, int M, int N, class A, class B> struct sxa_apply<F, scalars_t<A>, A,          mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, A                  a, const mat<B,M,N> & b) { return {vec_apply<F, void, A,        vec<B,M>>::impl(make_seq<0,M>{}, f, a,    b[J])...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:179:79: error: ‘scalars_t’ was not declared in this scope
         template<class F, int M, int N, class A, class B> struct sxa_apply<F, scalars_t<A>, A,          mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, A                  a, const mat<B,M,N> & b) { return {vec_apply<F, void, A,        vec<B,M>>::impl(make_seq<0,M>{}, f, a,    b[J])...}; } };
                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:179:79: note: suggested alternative: ‘scalars’
         template<class F, int M, int N, class A, class B> struct sxa_apply<F, scalars_t<A>, A,          mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, A                  a, const mat<B,M,N> & b) { return {vec_apply<F, void, A,        vec<B,M>>::impl(make_seq<0,M>{}, f, a,    b[J])...}; } };
                                                                               ^~~~~~~~~
                                                                               scalars
/usr/local/include/linalg-v3/linalg.h:179:66: error: ‘struct linalg::detail::sxa_apply’ redeclared as different kind of symbol
         template<class F, int M, int N, class A, class B> struct sxa_apply<F, scalars_t<A>, A,          mat<B,M,N>> { using type=mat<ret_t<F,A,B>,M,N>; enum {size=N}; template<int... J> static constexpr type impl(seq<J...>, F f, A                  a, const mat<B,M,N> & b) { return {vec_apply<F, void, A,        vec<B,M>>::impl(make_seq<0,M>{}, f, a,    b[J])...}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:162:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::sxa_apply’
         template<class F, class Void, class... T> struct sxa_apply {}; // Patterns of the form: scalar, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:181:53: error: ‘axa_apply’ is not a class template
         template<class F, class A          > struct axa_apply<F, scalars_t< >, quat<A>         > { using type=quat<ret_t<F,A  >>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a                   ) { return {f(a.x     ), f(a.y     ), f(a.z     ), f(a.w     )}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:181:66: error: ‘scalars_t’ was not declared in this scope
         template<class F, class A          > struct axa_apply<F, scalars_t< >, quat<A>         > { using type=quat<ret_t<F,A  >>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a                   ) { return {f(a.x     ), f(a.y     ), f(a.z     ), f(a.w     )}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:181:66: note: suggested alternative: ‘scalars’
         template<class F, class A          > struct axa_apply<F, scalars_t< >, quat<A>         > { using type=quat<ret_t<F,A  >>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a                   ) { return {f(a.x     ), f(a.y     ), f(a.z     ), f(a.w     )}; } };
                                                                  ^~~~~~~~~
                                                                  scalars
/usr/local/include/linalg-v3/linalg.h:181:53: error: ‘struct linalg::detail::axa_apply’ redeclared as different kind of symbol
         template<class F, class A          > struct axa_apply<F, scalars_t< >, quat<A>         > { using type=quat<ret_t<F,A  >>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a                   ) { return {f(a.x     ), f(a.y     ), f(a.z     ), f(a.w     )}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:160:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axa_apply’
         template<class F, class Void, class... T> struct axa_apply {}; // Patterns of the form: algebraic, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:182:53: error: ‘axa_apply’ is not a class template
         template<class F, class A, class B > struct axa_apply<F, scalars_t< >, quat<A>, quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, const quat<B> & b) { return {f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w)}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:182:66: error: ‘scalars_t’ was not declared in this scope
         template<class F, class A, class B > struct axa_apply<F, scalars_t< >, quat<A>, quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, const quat<B> & b) { return {f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w)}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:182:66: note: suggested alternative: ‘scalars’
         template<class F, class A, class B > struct axa_apply<F, scalars_t< >, quat<A>, quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, const quat<B> & b) { return {f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w)}; } };
                                                                  ^~~~~~~~~
                                                                  scalars
/usr/local/include/linalg-v3/linalg.h:182:53: error: ‘struct linalg::detail::axa_apply’ redeclared as different kind of symbol
         template<class F, class A, class B > struct axa_apply<F, scalars_t< >, quat<A>, quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, const quat<B> & b) { return {f(a.x, b.x), f(a.y, b.y), f(a.z, b.z), f(a.w, b.w)}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:160:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axa_apply’
         template<class F, class Void, class... T> struct axa_apply {}; // Patterns of the form: algebraic, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:183:53: error: ‘axs_apply’ is not a class template
         template<class F, class A, class B > struct axs_apply<F, scalars_t<B>, quat<A>, B      > { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, B               b) { return {f(a.x, b  ), f(a.y, b  ), f(a.z, b  ), f(a.w, b  )}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:183:66: error: ‘scalars_t’ was not declared in this scope
         template<class F, class A, class B > struct axs_apply<F, scalars_t<B>, quat<A>, B      > { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, B               b) { return {f(a.x, b  ), f(a.y, b  ), f(a.z, b  ), f(a.w, b  )}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:183:66: note: suggested alternative: ‘scalars’
         template<class F, class A, class B > struct axs_apply<F, scalars_t<B>, quat<A>, B      > { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, B               b) { return {f(a.x, b  ), f(a.y, b  ), f(a.z, b  ), f(a.w, b  )}; } };
                                                                  ^~~~~~~~~
                                                                  scalars
/usr/local/include/linalg-v3/linalg.h:183:53: error: ‘struct linalg::detail::axs_apply’ redeclared as different kind of symbol
         template<class F, class A, class B > struct axs_apply<F, scalars_t<B>, quat<A>, B      > { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, const quat<A> & a, B               b) { return {f(a.x, b  ), f(a.y, b  ), f(a.z, b  ), f(a.w, b  )}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:161:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::axs_apply’
         template<class F, class Void, class... T> struct axs_apply {}; // Patterns of the form: algebraic, scalar
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:184:53: error: ‘sxa_apply’ is not a class template
         template<class F, class A, class B > struct sxa_apply<F, scalars_t<A>, A,       quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, A               a, const quat<B> & b) { return {f(a,   b.x), f(a,   b.y), f(a,   b.z), f(a,   b.w)}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:184:66: error: ‘scalars_t’ was not declared in this scope
         template<class F, class A, class B > struct sxa_apply<F, scalars_t<A>, A,       quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, A               a, const quat<B> & b) { return {f(a,   b.x), f(a,   b.y), f(a,   b.z), f(a,   b.w)}; } };
                                                                  ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:184:66: note: suggested alternative: ‘scalars’
         template<class F, class A, class B > struct sxa_apply<F, scalars_t<A>, A,       quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, A               a, const quat<B> & b) { return {f(a,   b.x), f(a,   b.y), f(a,   b.z), f(a,   b.w)}; } };
                                                                  ^~~~~~~~~
                                                                  scalars
/usr/local/include/linalg-v3/linalg.h:184:53: error: ‘struct linalg::detail::sxa_apply’ redeclared as different kind of symbol
         template<class F, class A, class B > struct sxa_apply<F, scalars_t<A>, A,       quat<B>> { using type=quat<ret_t<F,A,B>>; enum {size=0}; static constexpr type impl(seq<>, F f, A               a, const quat<B> & b) { return {f(a,   b.x), f(a,   b.y), f(a,   b.z), f(a,   b.w)}; } };
                                                     ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:162:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::sxa_apply’
         template<class F, class Void, class... T> struct sxa_apply {}; // Patterns of the form: scalar, algebraic
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:186:68: error: ‘vec_apply’ is not a class template
         template<class F, class... A                      > struct vec_apply<F, scalars_t<A...>, A...> { using type = ret_t<F,A...>; enum {size=0}; static constexpr type impl(seq<>, F f, A... a) { return f(a...); } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:186:81: error: ‘scalars_t’ was not declared in this scope
         template<class F, class... A                      > struct vec_apply<F, scalars_t<A...>, A...> { using type = ret_t<F,A...>; enum {size=0}; static constexpr type impl(seq<>, F f, A... a) { return f(a...); } };
                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:186:81: note: suggested alternative: ‘scalars’
         template<class F, class... A                      > struct vec_apply<F, scalars_t<A...>, A...> { using type = ret_t<F,A...>; enum {size=0}; static constexpr type impl(seq<>, F f, A... a) { return f(a...); } };
                                                                                 ^~~~~~~~~
                                                                                 scalars
/usr/local/include/linalg-v3/linalg.h:186:92: error: expected parameter pack before ‘...’
         template<class F, class... A                      > struct vec_apply<F, scalars_t<A...>, A...> { using type = ret_t<F,A...>; enum {size=0}; static constexpr type impl(seq<>, F f, A... a) { return f(a...); } };
                                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:186:68: error: ‘struct linalg::detail::vec_apply’ redeclared as different kind of symbol
         template<class F, class... A                      > struct vec_apply<F, scalars_t<A...>, A...> { using type = ret_t<F,A...>; enum {size=0}; static constexpr type impl(seq<>, F f, A... a) { return f(a...); } };
                                                                    ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:159:58: note: previous declaration ‘template<class F, class Void, class ... T> struct linalg::detail::vec_apply’
         template<class F, class Void, class... T> struct vec_apply {}; // Patterns which contain only vectors or scalars
                                                          ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:187:67: error: expected template-name before ‘<’ token
         template<class F, class... T> struct any_apply : vec_apply<F,void,T...>, axa_apply<F,void,T...> , axs_apply<F,void,T...>, sxa_apply<F,void,T...>{};
                                                                   ^
/usr/local/include/linalg-v3/linalg.h:187:67: error: expected ‘{’ before ‘<’ token
/usr/local/include/linalg-v3/linalg.h:248:46: error: conflicting declaration of template ‘template<class T, class A, int I> struct linalg::_scalar’
     template<class T, class A, int I> struct _scalar
                                              ^~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:96:46: note: previous declaration ‘template<class T, class A, int I> struct linalg::_scalar’
     template<class T, class A, int I> struct _scalar;
                                              ^~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:260:55: error: ‘_lswizzle’ is not a class template
     template<class T, class A, int I0, int I1> struct _lswizzle<T,A,I0,I1>
                                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:260:74: error: conflicting declaration of template ‘template<class T, class A, int I0, int I1> struct linalg::_lswizzle’
     template<class T, class A, int I0, int I1> struct _lswizzle<T,A,I0,I1>
                                                                          ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:97:49: note: previous declaration ‘template<class T, class A, int ...I> struct linalg::_lswizzle’
     template<class T, class A, int... I> struct _lswizzle;
                                                 ^~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:271:63: error: ‘_lswizzle’ is not a class template
     template<class T, class A, int I0, int I1, int I2> struct _lswizzle<T,A,I0,I1,I2>
                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:271:85: error: conflicting declaration of template ‘template<class T, class A, int I0, int I1, int I2> struct linalg::_lswizzle’
     template<class T, class A, int I0, int I1, int I2> struct _lswizzle<T,A,I0,I1,I2>
                                                                                     ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:97:49: note: previous declaration ‘template<class T, class A, int ...I> struct linalg::_lswizzle’
     template<class T, class A, int... I> struct _lswizzle;
                                                 ^~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:282:71: error: ‘_lswizzle’ is not a class template
     template<class T, class A, int I0, int I1, int I2, int I3> struct _lswizzle<T,A,I0,I1,I2,I3>
                                                                       ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:282:96: error: conflicting declaration of template ‘template<class T, class A, int I0, int I1, int I2, int I3> struct linalg::_lswizzle’
     template<class T, class A, int I0, int I1, int I2, int I3> struct _lswizzle<T,A,I0,I1,I2,I3>
                                                                                                ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:97:49: note: previous declaration ‘template<class T, class A, int ...I> struct linalg::_lswizzle’
     template<class T, class A, int... I> struct _lswizzle;
                                                 ^~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:293:49: error: conflicting declaration of template ‘template<class T, class A, int ...I> struct linalg::_rswizzle’
     template<class T, class A, int... I> struct _rswizzle
                                                 ^~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:98:49: note: previous declaration ‘template<class T, class A, int ...I> struct linalg::_rswizzle’
     template<class T, class A, int... I> struct _rswizzle;
                                                 ^~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:304:30: error: ‘vec’ is not a class template
     template<class T> struct vec<T,1>
                              ^~~
/usr/local/include/linalg-v3/linalg.h:304:37: error: conflicting declaration of template ‘template<class T> struct linalg::vec’
     template<class T> struct vec<T,1>
                                     ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note: previous declaration ‘template<class T, int M> struct linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:327:30: error: ‘vec’ is not a class template
     template<class T> struct vec<T,2>
                              ^~~
/usr/local/include/linalg-v3/linalg.h:327:37: error: conflicting declaration of template ‘template<class T> struct linalg::vec’
     template<class T> struct vec<T,2>
                                     ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note: previous declaration ‘template<class T, int M> struct linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:362:30: error: ‘vec’ is not a class template
     template<class T> struct vec<T,3>
                              ^~~
/usr/local/include/linalg-v3/linalg.h:362:37: error: conflicting declaration of template ‘template<class T> struct linalg::vec’
     template<class T> struct vec<T,3>
                                     ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note: previous declaration ‘template<class T, int M> struct linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:423:30: error: ‘vec’ is not a class template
     template<class T> struct vec<T,4>
                              ^~~
/usr/local/include/linalg-v3/linalg.h:423:37: error: conflicting declaration of template ‘template<class T> struct linalg::vec’
     template<class T> struct vec<T,4>
                                     ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note: previous declaration ‘template<class T, int M> struct linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:536:37: error: ‘mat’ is not a class template
     template<class T, int M> struct mat<T,M,1>
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:536:46: error: conflicting declaration of template ‘template<class T, int M> struct linalg::mat’
     template<class T, int M> struct mat<T,M,1>
                                              ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note: previous declaration ‘template<class T, int M, int N> struct linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:553:37: error: ‘mat’ is not a class template
     template<class T, int M> struct mat<T,M,2>
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:553:46: error: conflicting declaration of template ‘template<class T, int M> struct linalg::mat’
     template<class T, int M> struct mat<T,M,2>
                                              ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note: previous declaration ‘template<class T, int M, int N> struct linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:570:37: error: ‘mat’ is not a class template
     template<class T, int M> struct mat<T,M,3>
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:570:46: error: conflicting declaration of template ‘template<class T, int M> struct linalg::mat’
     template<class T, int M> struct mat<T,M,3>
                                              ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note: previous declaration ‘template<class T, int M, int N> struct linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:587:37: error: ‘mat’ is not a class template
     template<class T, int M> struct mat<T,M,4>
                                     ^~~
/usr/local/include/linalg-v3/linalg.h:587:46: error: conflicting declaration of template ‘template<class T, int M> struct linalg::mat’
     template<class T, int M> struct mat<T,M,4>
                                              ^
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:74:44: note: previous declaration ‘template<class T, int M, int N> struct linalg::mat’
     template<class T, int M, int N> struct mat;
                                            ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:609:30: error: conflicting declaration of template ‘template<class T> struct linalg::quat’
     template<class T> struct quat
                              ^~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:77:30: note: previous declaration ‘template<class T> struct linalg::quat’
     template<class T> struct quat;
                              ^~~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:627:59: error: ‘detail’ has not been declared
     template<class A, class B> using compare_t = typename detail::any_compare<detail::unpack_t<A>, detail::unpack_t<B>>::type;
                                                           ^~~~~~
/usr/local/include/linalg-v3/linalg.h:628:42: error: ‘compare_t’ does not name a type; did you mean ‘locale_t’?
     template<class A, class B> constexpr compare_t<A,B> compare(const A & a, const B & b) { return detail::any_compare<detail::unpack_t<A>, detail::unpack_t<B>>()(a,b); }
                                          ^~~~~~~~~
                                          locale_t
/usr/local/include/linalg-v3/linalg.h:641:62: error: ‘vec’ does not name a type
     template<class T, int M> constexpr const T * begin(const vec<T,M> & a) { return a.data(); }
                                                              ^~~
/usr/local/include/linalg-v3/linalg.h:641:65: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr const T * begin(const vec<T,M> & a) { return a.data(); }
                                                                 ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr const T* ralgo::begin(int)’:
/usr/local/include/linalg-v3/linalg.h:641:85: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr const T * begin(const vec<T,M> & a) { return a.data(); }
                                                                                     ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:642:62: error: ‘vec’ does not name a type
     template<class T, int M> constexpr const T * end  (const vec<T,M> & a) { return a.data() + M; }
                                                              ^~~
/usr/local/include/linalg-v3/linalg.h:642:65: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr const T * end  (const vec<T,M> & a) { return a.data() + M; }
                                                                 ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr const T* ralgo::end(int)’:
/usr/local/include/linalg-v3/linalg.h:642:85: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr const T * end  (const vec<T,M> & a) { return a.data() + M; }
                                                                                     ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:643:53: error: ‘vec’ does not name a type
     template<class T, int M, int N> constexpr const vec<T,M> * begin(const mat<T,M,N> & a) { return a._; }
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:644:53: error: ‘vec’ does not name a type
     template<class T, int M, int N> constexpr const vec<T,M> * end  (const mat<T,M,N> & a) { return a._ + N; }
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:646:50: error: ‘template<class T, int M> constexpr T* const linalg::begin’ conflicts with a previous declaration
     template<class T, int M> constexpr T * begin(vec<T,M> & a) { return a.data(); }
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:641:50: note: previous declaration ‘constexpr const T* ralgo::begin(int)’
     template<class T, int M> constexpr const T * begin(const vec<T,M> & a) { return a.data(); }
                                                  ^~~~~
/usr/local/include/linalg-v3/linalg.h:646:59: error: expected primary-expression before ‘&’ token
     template<class T, int M> constexpr T * begin(vec<T,M> & a) { return a.data(); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h:646:61: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T * begin(vec<T,M> & a) { return a.data(); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:646:64: error: expected ‘;’ before ‘{’ token
     template<class T, int M> constexpr T * begin(vec<T,M> & a) { return a.data(); }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:647:50: error: ‘template<class T, int M> constexpr T* const linalg::end’ conflicts with a previous declaration
     template<class T, int M> constexpr T * end  (vec<T,M> & a) { return a.data() + M; }
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:642:50: note: previous declaration ‘constexpr const T* ralgo::end(int)’
     template<class T, int M> constexpr const T * end  (const vec<T,M> & a) { return a.data() + M; }
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:647:59: error: expected primary-expression before ‘&’ token
     template<class T, int M> constexpr T * end  (vec<T,M> & a) { return a.data() + M; }
                                                           ^
/usr/local/include/linalg-v3/linalg.h:647:61: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T * end  (vec<T,M> & a) { return a.data() + M; }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:647:64: error: expected ‘;’ before ‘{’ token
     template<class T, int M> constexpr T * end  (vec<T,M> & a) { return a.data() + M; }
                                                                ^
/usr/local/include/linalg-v3/linalg.h:648:47: error: ‘vec’ does not name a type
     template<class T, int M, int N> constexpr vec<T,M> * begin(mat<T,M,N> & a) { return a._; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:649:47: error: ‘vec’ does not name a type
     template<class T, int M, int N> constexpr vec<T,M> * end  (mat<T,M,N> & a) { return a._ + N; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:656:74: error: ‘vec’ does not name a type
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:656:77: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:656:102: error: ‘b’ was not declared in this scope
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:657:74: error: ‘vec’ does not name a type
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,2> & b) { return f(f(a, b[0]), b[1]); }
                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:657:77: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,2> & b) { return f(f(a, b[0]), b[1]); }
                                                                             ^
/usr/local/include/linalg-v3/linalg.h:657:86: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,2> & b) { return f(f(a, b[0]), b[1]); }
                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:657:104: error: ‘b’ was not declared in this scope
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,2> & b) { return f(f(a, b[0]), b[1]); }
                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:658:74: error: ‘vec’ does not name a type
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,3> & b) { return f(f(f(a, b[0]), b[1]), b[2]); }
                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:658:77: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,3> & b) { return f(f(f(a, b[0]), b[1]), b[2]); }
                                                                             ^
/usr/local/include/linalg-v3/linalg.h:658:86: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,3> & b) { return f(f(f(a, b[0]), b[1]), b[2]); }
                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:658:106: error: ‘b’ was not declared in this scope
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,3> & b) { return f(f(f(a, b[0]), b[1]), b[2]); }
                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:659:74: error: ‘vec’ does not name a type
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,4> & b) { return f(f(f(f(a, b[0]), b[1]), b[2]), b[3]); }
                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:659:77: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,4> & b) { return f(f(f(f(a, b[0]), b[1]), b[2]), b[3]); }
                                                                             ^
/usr/local/include/linalg-v3/linalg.h:659:86: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,4> & b) { return f(f(f(f(a, b[0]), b[1]), b[2]), b[3]); }
                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:659:108: error: ‘b’ was not declared in this scope
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,4> & b) { return f(f(f(f(a, b[0]), b[1]), b[2]), b[3]); }
                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:660:81: error: ‘mat’ does not name a type
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,1> & b) { return fold(f, a, b[0]); }
                                                                                 ^~~
/usr/local/include/linalg-v3/linalg.h:660:84: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,1> & b) { return fold(f, a, b[0]); }
                                                                                    ^
/usr/local/include/linalg-v3/linalg.h:660:95: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,1> & b) { return fold(f, a, b[0]); }
                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:660:117: error: ‘b’ was not declared in this scope
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,1> & b) { return fold(f, a, b[0]); }
                                                                                                                     ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:661:81: error: ‘mat’ does not name a type
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,2> & b) { return fold(f, fold(f, a, b[0]), b[1]); }
                                                                                 ^~~
/usr/local/include/linalg-v3/linalg.h:661:84: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,2> & b) { return fold(f, fold(f, a, b[0]), b[1]); }
                                                                                    ^
/usr/local/include/linalg-v3/linalg.h:661:95: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,2> & b) { return fold(f, fold(f, a, b[0]), b[1]); }
                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:661:125: error: ‘b’ was not declared in this scope
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,2> & b) { return fold(f, fold(f, a, b[0]), b[1]); }
                                                                                                                             ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:662:81: error: ‘mat’ does not name a type
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,3> & b) { return fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]); }
                                                                                 ^~~
/usr/local/include/linalg-v3/linalg.h:662:84: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,3> & b) { return fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]); }
                                                                                    ^
/usr/local/include/linalg-v3/linalg.h:662:95: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,3> & b) { return fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]); }
                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:662:133: error: ‘b’ was not declared in this scope
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,3> & b) { return fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]); }
                                                                                                                                     ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:663:81: error: ‘mat’ does not name a type
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,4> & b) { return fold(f, fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]), b[3]); }
                                                                                 ^~~
/usr/local/include/linalg-v3/linalg.h:663:84: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,4> & b) { return fold(f, fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]), b[3]); }
                                                                                    ^
/usr/local/include/linalg-v3/linalg.h:663:95: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,4> & b) { return fold(f, fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]), b[3]); }
                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:663:141: error: ‘b’ was not declared in this scope
     template<class F, class A, class B, int M> constexpr A fold(F f, A a, const mat<B,M,4> & b) { return fold(f, fold(f, fold(f, fold(f, a, b[0]), b[1]), b[2]), b[3]); }
                                                                                                                                             ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:664:74: error: ‘quat’ does not name a type
     template<class F, class A, class B> constexpr A fold(F f, A a, const quat<B> & b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }
                                                                          ^~~~
/usr/local/include/linalg-v3/linalg.h:664:78: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class F, class A, class B> constexpr A fold(F f, A a, const quat<B> & b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }
                                                                              ^
/usr/local/include/linalg-v3/linalg.h:664:85: error: ‘constexpr A ralgo::fold(F, A, int)’ conflicts with a previous declaration
     template<class F, class A, class B> constexpr A fold(F f, A a, const quat<B> & b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }
                                                                                     ^
/usr/local/include/linalg-v3/linalg.h:656:53: note: previous declaration ‘constexpr A ralgo::fold(F, A, int)’
     template<class F, class A, class B> constexpr A fold(F f, A a, const vec<B,1> & b) { return f(a, b[0]); }
                                                     ^~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr A ralgo::fold(F, A, int)’:
/usr/local/include/linalg-v3/linalg.h:664:107: error: ‘b’ was not declared in this scope
     template<class F, class A, class B> constexpr A fold(F f, A a, const quat<B> & b) { return f(f(f(f(a, b.x), b.y), b.z), b.w); }
                                                                                                           ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:667:60: error: ‘detail’ has not been declared
     template<class F, class... A> using apply_t = typename detail::any_apply<F,detail::unpack_t<A>...>::type;
                                                            ^~~~~~
/usr/local/include/linalg-v3/linalg.h:668:64: error: ‘detail’ has not been declared
     template<class F, class... A> using vec_apply_t = typename detail::vec_apply<F,void,detail::unpack_t<A>...>::type;
                                                                ^~~~~~
/usr/local/include/linalg-v3/linalg.h:669:64: error: ‘detail’ has not been declared
     template<class F, class... A> using axa_apply_t = typename detail::axa_apply<F,void,detail::unpack_t<A>...>::type;
                                                                ^~~~~~
/usr/local/include/linalg-v3/linalg.h:670:64: error: ‘detail’ has not been declared
     template<class F, class... A> using axs_apply_t = typename detail::axs_apply<F,void,detail::unpack_t<A>...>::type;
                                                                ^~~~~~
/usr/local/include/linalg-v3/linalg.h:671:64: error: ‘detail’ has not been declared
     template<class F, class... A> using sxa_apply_t = typename detail::sxa_apply<F,void,detail::unpack_t<A>...>::type;
                                                                ^~~~~~
/usr/local/include/linalg-v3/linalg.h:674:45: error: ‘apply_t’ does not name a type
     template<class F, class... A> constexpr apply_t<F,A...> apply(F func, const A & ... args) { return detail::any_apply<F,detail::unpack_t<A>...>::impl(detail::make_seq<0,detail::any_apply<F,detail::unpack_t<A>...>::size>{}, func, args...); }
                                             ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:677:42: error: ‘apply_t’ does not name a type
     template<class A, class F> constexpr apply_t<F,A> map(const A & a, F func) { return apply(func, a); }
                                          ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:680:51: error: ‘apply_t’ does not name a type
     template<class A, class B, class F> constexpr apply_t<F,A,B> zip(const A & a, const B & b, F func) { return apply(func, a, b); }
                                                   ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:687:33: error: ‘apply_t’ does not name a type
     template<class A> constexpr apply_t<detail::op_pos, A> operator + (const A & a) { return apply(detail::op_pos{}, a); }
                                 ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:688:33: error: ‘apply_t’ does not name a type
     template<class A> constexpr apply_t<detail::op_neg, A> operator - (const A & a) { return apply(detail::op_neg{}, a); }
                                 ^~~~~~~
/usr/local/include/linalg-v3/linalg.h:691:33: error: ‘vec_apply_t’ does not name a type
     template<class A> constexpr vec_apply_t<detail::op_cmp, A> operator ~ (const A & a) { return apply(detail::op_cmp{}, a); }
                                 ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:692:33: error: ‘vec_apply_t’ does not name a type
     template<class A> constexpr vec_apply_t<detail::op_not, A> operator ! (const A & a) { return apply(detail::op_not{}, a); }
                                 ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:693:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_add, A, B> operator +  (const A & a, const B & b) { return apply(detail::op_add{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:694:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_sub, A, B> operator -  (const A & a, const B & b) { return apply(detail::op_sub{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:695:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_mul, A, B> operator *  (const A & a, const B & b) { return apply(detail::op_mul{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:696:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_div, A, B> operator /  (const A & a, const B & b) { return apply(detail::op_div{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:697:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_mod, A, B> operator %  (const A & a, const B & b) { return apply(detail::op_mod{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:698:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_un,  A, B> operator |  (const A & a, const B & b) { return apply(detail::op_un{},  a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:699:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_xor, A, B> operator ^  (const A & a, const B & b) { return apply(detail::op_xor{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:700:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_int, A, B> operator &  (const A & a, const B & b) { return apply(detail::op_int{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:701:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_lsh, A, B> operator << (const A & a, const B & b) { return apply(detail::op_lsh{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:702:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_rsh, A, B> operator >> (const A & a, const B & b) { return apply(detail::op_rsh{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:705:42: error: ‘axa_apply_t’ does not name a type
     template<class A, class B> constexpr axa_apply_t<detail::op_add, A, B> operator + (const A & a, const B & b) { return apply(detail::op_add{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:706:42: error: ‘axa_apply_t’ does not name a type
     template<class A, class B> constexpr axa_apply_t<detail::op_sub, A, B> operator - (const A & a, const B & b) { return apply(detail::op_sub{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:707:42: error: ‘axs_apply_t’ does not name a type
     template<class A, class B> constexpr axs_apply_t<detail::op_mul, A, B> operator * (const A & a, const B & b) { return apply(detail::op_mul{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:708:42: error: ‘sxa_apply_t’ does not name a type
     template<class A, class B> constexpr sxa_apply_t<detail::op_mul, A, B> operator * (const A & a, const B & b) { return apply(detail::op_mul{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:709:42: error: ‘axs_apply_t’ does not name a type
     template<class A, class B> constexpr axs_apply_t<detail::op_div, A, B> operator / (const A & a, const B & b) { return apply(detail::op_div{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:724:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr bool any (const vec<T,M> & a) { return fold(detail::op_or{}, false, a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:724:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr bool any (const vec<T,M> & a) { return fold(detail::op_or{}, false, a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr bool ralgo::any(int)’:
/usr/local/include/linalg-v3/linalg.h:724:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr bool any (const vec<T,M> & a) { return fold(detail::op_or{}, false, a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:724:108: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr bool any (const vec<T,M> & a) { return fold(detail::op_or{}, false, a); }
                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h:724:79: error: there are no arguments to ‘fold’ that depend on a template parameter, so a declaration of ‘fold’ must be available [-fpermissive]
     template<class T, int M> constexpr bool any (const vec<T,M> & a) { return fold(detail::op_or{}, false, a); }
                                                                               ^~~~
/usr/local/include/linalg-v3/linalg.h:724:79: note: (if you use ‘-fpermissive’, G++ will accept your code, but allowing the use of an undeclared name is deprecated)
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:725:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr bool all (const vec<T,M> & a) { return fold(detail::op_and{}, true, a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:725:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr bool all (const vec<T,M> & a) { return fold(detail::op_and{}, true, a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr bool ralgo::all(int)’:
/usr/local/include/linalg-v3/linalg.h:725:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr bool all (const vec<T,M> & a) { return fold(detail::op_and{}, true, a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:725:108: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr bool all (const vec<T,M> & a) { return fold(detail::op_and{}, true, a); }
                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h:725:79: error: there are no arguments to ‘fold’ that depend on a template parameter, so a declaration of ‘fold’ must be available [-fpermissive]
     template<class T, int M> constexpr bool all (const vec<T,M> & a) { return fold(detail::op_and{}, true, a); }
                                                                               ^~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:726:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T sum    (const vec<T,M> & a) { return fold(detail::op_add{}, T(0), a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:726:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T sum    (const vec<T,M> & a) { return fold(detail::op_add{}, T(0), a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::sum(int)’:
/usr/local/include/linalg-v3/linalg.h:726:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr T sum    (const vec<T,M> & a) { return fold(detail::op_add{}, T(0), a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:726:108: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T sum    (const vec<T,M> & a) { return fold(detail::op_add{}, T(0), a); }
                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:727:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T product(const vec<T,M> & a) { return fold(detail::op_mul{}, T(1), a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:727:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T product(const vec<T,M> & a) { return fold(detail::op_mul{}, T(1), a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::product(int)’:
/usr/local/include/linalg-v3/linalg.h:727:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr T product(const vec<T,M> & a) { return fold(detail::op_mul{}, T(1), a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:727:108: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T product(const vec<T,M> & a) { return fold(detail::op_mul{}, T(1), a); }
                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:728:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T minelem(const vec<T,M> & a) { return fold(detail::min{}, a[0], a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:728:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T minelem(const vec<T,M> & a) { return fold(detail::min{}, a[0], a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::minelem(int)’:
/usr/local/include/linalg-v3/linalg.h:728:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr T minelem(const vec<T,M> & a) { return fold(detail::min{}, a[0], a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:728:99: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T minelem(const vec<T,M> & a) { return fold(detail::min{}, a[0], a); }
                                                                                                   ^
/usr/local/include/linalg-v3/linalg.h:728:79: error: there are no arguments to ‘fold’ that depend on a template parameter, so a declaration of ‘fold’ must be available [-fpermissive]
     template<class T, int M> constexpr T minelem(const vec<T,M> & a) { return fold(detail::min{}, a[0], a); }
                                                                               ^~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:729:56: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T maxelem(const vec<T,M> & a) { return fold(detail::max{}, a[0], a); }
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:729:59: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T maxelem(const vec<T,M> & a) { return fold(detail::max{}, a[0], a); }
                                                           ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::maxelem(int)’:
/usr/local/include/linalg-v3/linalg.h:729:84: error: ‘detail’ has not been declared
     template<class T, int M> constexpr T maxelem(const vec<T,M> & a) { return fold(detail::max{}, a[0], a); }
                                                                                    ^~~~~~
/usr/local/include/linalg-v3/linalg.h:729:99: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T maxelem(const vec<T,M> & a) { return fold(detail::max{}, a[0], a); }
                                                                                                   ^
/usr/local/include/linalg-v3/linalg.h:729:79: error: there are no arguments to ‘fold’ that depend on a template parameter, so a declaration of ‘fold’ must be available [-fpermissive]
     template<class T, int M> constexpr T maxelem(const vec<T,M> & a) { return fold(detail::max{}, a[0], a); }
                                                                               ^~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:732:47: error: ‘vec’ does not name a type
     template<class T, int M> int argmin(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] < a[j]) j = i; return j; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:732:50: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> int argmin(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] < a[j]) j = i; return j; }
                                                  ^
/usr/local/include/linalg-v3/linalg.h: In function ‘int ralgo::argmin(int)’:
/usr/local/include/linalg-v3/linalg.h:732:98: error: ‘a’ was not declared in this scope
     template<class T, int M> int argmin(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] < a[j]) j = i; return j; }
                                                                                                  ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:733:47: error: ‘vec’ does not name a type
     template<class T, int M> int argmax(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] > a[j]) j = i; return j; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:733:50: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> int argmax(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] > a[j]) j = i; return j; }
                                                  ^
/usr/local/include/linalg-v3/linalg.h: In function ‘int ralgo::argmax(int)’:
/usr/local/include/linalg-v3/linalg.h:733:98: error: ‘a’ was not declared in this scope
     template<class T, int M> int argmax(const vec<T,M> & a) { int j=0; for(int i=1; i<M; ++i) if(a[i] > a[j]) j = i; return j; }
                                                                                                  ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:736:79: error: ‘vec’ does not name a type
     template<int... I, class T, int M>                              constexpr vec<T,sizeof...(I)>   swizzle(const vec<T,M> & a)   { return {a[I]...}; }
                                                                               ^~~
/usr/local/include/linalg-v3/linalg.h:737:79: error: ‘vec’ does not name a type
     template<int I0, int I1, class T, int M>                        constexpr vec<T,I1-I0>          subvec (const vec<T,M> & a)   { return detail::swizzle(a, detail::make_seq<I0,I1>{}); }
                                                                               ^~~
/usr/local/include/linalg-v3/linalg.h:738:79: error: ‘mat’ does not name a type
     template<int I0, int J0, int I1, int J1, class T, int M, int N> constexpr mat<T,I1-I0,J1-J0>    submat (const mat<T,M,N> & a) { return detail::swizzle(a, detail::make_seq<I0,I1>{}, detail::make_seq<J0,J1>{}); }
                                                                               ^~~
/usr/local/include/linalg-v3/linalg.h:741:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_abs,   A> abs  (const A & a) { return apply(detail::std_abs{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:742:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_floor, A> floor(const A & a) { return apply(detail::std_floor{}, a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:743:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_ceil,  A> ceil (const A & a) { return apply(detail::std_ceil{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:744:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_exp,   A> exp  (const A & a) { return apply(detail::std_exp{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:745:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_log,   A> log  (const A & a) { return apply(detail::std_log{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:746:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_log10, A> log10(const A & a) { return apply(detail::std_log10{}, a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:747:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_sqrt,  A> sqrt (const A & a) { return apply(detail::std_sqrt{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:748:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_sin,   A> sin  (const A & a) { return apply(detail::std_sin{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:749:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_cos,   A> cos  (const A & a) { return apply(detail::std_cos{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:750:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_tan,   A> tan  (const A & a) { return apply(detail::std_tan{},   a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:751:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_asin,  A> asin (const A & a) { return apply(detail::std_asin{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:752:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_acos,  A> acos (const A & a) { return apply(detail::std_acos{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:753:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_atan,  A> atan (const A & a) { return apply(detail::std_atan{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:754:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_sinh,  A> sinh (const A & a) { return apply(detail::std_sinh{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:755:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_cosh,  A> cosh (const A & a) { return apply(detail::std_cosh{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:756:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_tanh,  A> tanh (const A & a) { return apply(detail::std_tanh{},  a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:757:23: error: ‘vec_apply_t’ does not name a type
     template<class A> vec_apply_t<detail::std_round, A> round(const A & a) { return apply(detail::std_round{}, a); }
                       ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:759:32: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> vec_apply_t<detail::std_fmod,     A, B> fmod    (const A & a, const B & b) { return apply(detail::std_fmod{},     a, b); }
                                ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:760:32: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> vec_apply_t<detail::std_pow,      A, B> pow     (const A & a, const B & b) { return apply(detail::std_pow{},      a, b); }
                                ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:761:32: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> vec_apply_t<detail::std_atan2,    A, B> atan2   (const A & a, const B & b) { return apply(detail::std_atan2{},    a, b); }
                                ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:762:32: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> vec_apply_t<detail::std_copysign, A, B> copysign(const A & a, const B & b) { return apply(detail::std_copysign{}, a, b); }
                                ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:765:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_eq, A, B> equal  (const A & a, const B & b) { return apply(detail::op_eq{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:766:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_ne, A, B> nequal (const A & a, const B & b) { return apply(detail::op_ne{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:767:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_lt, A, B> less   (const A & a, const B & b) { return apply(detail::op_lt{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:768:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_gt, A, B> greater(const A & a, const B & b) { return apply(detail::op_gt{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:769:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_le, A, B> lequal (const A & a, const B & b) { return apply(detail::op_le{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:770:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::op_ge, A, B> gequal (const A & a, const B & b) { return apply(detail::op_ge{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:773:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::min, A, B> min(const A & a, const B & b) { return apply(detail::min{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:774:42: error: ‘vec_apply_t’ does not name a type
     template<class A, class B> constexpr vec_apply_t<detail::max, A, B> max(const A & a, const B & b) { return apply(detail::max{}, a, b); }
                                          ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:775:51: error: ‘vec_apply_t’ does not name a type
     template<class X, class L, class H> constexpr vec_apply_t<detail::clamp,  X, L, H> clamp (const X & x, const L & l, const H & h) { return apply(detail::clamp{},  x, l, h); }
                                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:776:51: error: ‘vec_apply_t’ does not name a type
     template<class P, class A, class B> constexpr vec_apply_t<detail::select, P, A, B> select(const P & p, const A & a, const B & b) { return apply(detail::select{}, p, a, b); }
                                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:777:51: error: ‘vec_apply_t’ does not name a type
     template<class A, class B, class T> constexpr vec_apply_t<detail::lerp,   A, B, T> lerp  (const A & a, const B & b, const T & t) { return apply(detail::lerp{},   a, b, t); }
                                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:780:58: error: ‘vec’ does not name a type
     template<class T> constexpr T        cross    (const vec<T,2> & a, const vec<T,2> & b)      { return a[0]*b[1]-a[1]*b[0]; }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:780:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T        cross    (const vec<T,2> & a, const vec<T,2> & b)      { return a[0]*b[1]-a[1]*b[0]; }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::cross(int)’:
/usr/local/include/linalg-v3/linalg.h:780:106: error: ‘a’ was not declared in this scope
     template<class T> constexpr T        cross    (const vec<T,2> & a, const vec<T,2> & b)      { return a[0]*b[1]-a[1]*b[0]; }
                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h:780:111: error: ‘b’ was not declared in this scope
     template<class T> constexpr T        cross    (const vec<T,2> & a, const vec<T,2> & b)      { return a[0]*b[1]-a[1]*b[0]; }
                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:781:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,2> cross    (T a, const vec<T,2> & b)                     { return {-a*b[1], a*b[0]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:782:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,2> cross    (const vec<T,2> & a, T b)                     { return {a[1]*b, -a[0]*b}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:783:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3> cross    (const vec<T,3> & a, const vec<T,3> & b)      { return {a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:784:58: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:784:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::dot(int)’:
/usr/local/include/linalg-v3/linalg.h:784:110: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                                                                                              ^
/usr/local/include/linalg-v3/linalg.h:784:112: error: ‘b’ was not declared in this scope
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                                                                                                ^
/usr/local/include/linalg-v3/linalg.h:784:106: error: there are no arguments to ‘sum’ that depend on a template parameter, so a declaration of ‘sum’ must be available [-fpermissive]
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:785:58: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T length2  (const vec<T,M> & a)                          { return dot(a,a); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:785:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T length2  (const vec<T,M> & a)                          { return dot(a,a); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::length2(int)’:
/usr/local/include/linalg-v3/linalg.h:785:110: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T length2  (const vec<T,M> & a)                          { return dot(a,a); }
                                                                                                              ^
/usr/local/include/linalg-v3/linalg.h:785:106: error: there are no arguments to ‘dot’ that depend on a template parameter, so a declaration of ‘dot’ must be available [-fpermissive]
     template<class T, int M> constexpr T length2  (const vec<T,M> & a)                          { return dot(a,a); }
                                                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:786:58: error: ‘vec’ does not name a type
     template<class T, int M> T           length   (const vec<T,M> & a)                          { return std::sqrt(length2(a)); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:786:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> T           length   (const vec<T,M> & a)                          { return std::sqrt(length2(a)); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::length(int)’:
/usr/local/include/linalg-v3/linalg.h:786:124: error: ‘a’ was not declared in this scope
     template<class T, int M> T           length   (const vec<T,M> & a)                          { return std::sqrt(length2(a)); }
                                                                                                                            ^
/usr/local/include/linalg-v3/linalg.h:786:116: error: there are no arguments to ‘length2’ that depend on a template parameter, so a declaration of ‘length2’ must be available [-fpermissive]
     template<class T, int M> T           length   (const vec<T,M> & a)                          { return std::sqrt(length2(a)); }
                                                                                                                    ^~~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:787:30: error: ‘vec’ does not name a type
     template<class T, int M> vec<T,M>    normalize(const vec<T,M> & a)                          { return a / length(a); }
                              ^~~
/usr/local/include/linalg-v3/linalg.h:788:58: error: ‘vec’ does not name a type
     template<class T, int M> constexpr T distance2(const vec<T,M> & a, const vec<T,M> & b)      { return length2(b-a); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:788:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> constexpr T distance2(const vec<T,M> & a, const vec<T,M> & b)      { return length2(b-a); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::distance2(int)’:
/usr/local/include/linalg-v3/linalg.h:788:114: error: ‘b’ was not declared in this scope
     template<class T, int M> constexpr T distance2(const vec<T,M> & a, const vec<T,M> & b)      { return length2(b-a); }
                                                                                                                  ^
/usr/local/include/linalg-v3/linalg.h:788:116: error: ‘a’ was not declared in this scope
     template<class T, int M> constexpr T distance2(const vec<T,M> & a, const vec<T,M> & b)      { return length2(b-a); }
                                                                                                                    ^
/usr/local/include/linalg-v3/linalg.h:788:106: error: there are no arguments to ‘length2’ that depend on a template parameter, so a declaration of ‘length2’ must be available [-fpermissive]
     template<class T, int M> constexpr T distance2(const vec<T,M> & a, const vec<T,M> & b)      { return length2(b-a); }
                                                                                                          ^~~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:789:58: error: ‘vec’ does not name a type
     template<class T, int M> T           distance (const vec<T,M> & a, const vec<T,M> & b)      { return length(b-a); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:789:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> T           distance (const vec<T,M> & a, const vec<T,M> & b)      { return length(b-a); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::distance(int)’:
/usr/local/include/linalg-v3/linalg.h:789:113: error: ‘b’ was not declared in this scope
     template<class T, int M> T           distance (const vec<T,M> & a, const vec<T,M> & b)      { return length(b-a); }
                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h:789:115: error: ‘a’ was not declared in this scope
     template<class T, int M> T           distance (const vec<T,M> & a, const vec<T,M> & b)      { return length(b-a); }
                                                                                                                   ^
/usr/local/include/linalg-v3/linalg.h:789:106: error: there are no arguments to ‘length’ that depend on a template parameter, so a declaration of ‘length’ must be available [-fpermissive]
     template<class T, int M> T           distance (const vec<T,M> & a, const vec<T,M> & b)      { return length(b-a); }
                                                                                                          ^~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:790:58: error: ‘vec’ does not name a type
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:790:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::uangle(int)’:
/usr/local/include/linalg-v3/linalg.h:790:107: error: ‘a’ was not declared in this scope
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                           ^
/usr/local/include/linalg-v3/linalg.h:790:109: error: ‘b’ was not declared in this scope
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                             ^
/usr/local/include/linalg-v3/linalg.h:790:103: error: there are no arguments to ‘dot’ that depend on a template parameter, so a declaration of ‘dot’ must be available [-fpermissive]
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                       ^~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:791:58: error: ‘vec’ does not name a type
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:791:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::angle(int)’:
/usr/local/include/linalg-v3/linalg.h:791:123: error: ‘a’ was not declared in this scope
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                                                                                           ^
/usr/local/include/linalg-v3/linalg.h:791:113: error: there are no arguments to ‘normalize’ that depend on a template parameter, so a declaration of ‘normalize’ must be available [-fpermissive]
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                                                                                 ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:791:137: error: ‘b’ was not declared in this scope
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                                                                                                         ^
/usr/local/include/linalg-v3/linalg.h:791:127: error: there are no arguments to ‘normalize’ that depend on a template parameter, so a declaration of ‘normalize’ must be available [-fpermissive]
     template<class T, int M> T           angle    (const vec<T,M> & a, const vec<T,M> & b)      { return uangle(normalize(a), normalize(b)); }
                                                                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:792:30: error: ‘vec’ does not name a type
     template<class T, int M> vec<T,M>    nlerp    (const vec<T,M> & a, const vec<T,M> & b, T t) { return normalize(lerp(a,b,t)); }
                              ^~~
/usr/local/include/linalg-v3/linalg.h:793:30: error: ‘vec’ does not name a type
     template<class T, int M> vec<T,M>    slerp    (const vec<T,M> & a, const vec<T,M> & b, T t) { T th=uangle(a,b); return th == 0 ? a : a*(std::sin(th*(1-t))/std::sin(th)) + b*(std::sin(th*t)/std::sin(th)); }
                              ^~~
/usr/local/include/linalg-v3/linalg.h:800:40: error: ‘vec’ does not name a type
     template<class T, int M> constexpr vec<T,M> operator * (const mat<T,M,1> & a, const vec<T,1> & b) { return a[0]*b[0]; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:801:40: error: ‘vec’ does not name a type
     template<class T, int M> constexpr vec<T,M> operator * (const mat<T,M,2> & a, const vec<T,2> & b) { return a[0]*b[0] + a[1]*b[1]; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:802:40: error: ‘vec’ does not name a type
     template<class T, int M> constexpr vec<T,M> operator * (const mat<T,M,3> & a, const vec<T,3> & b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:803:40: error: ‘vec’ does not name a type
     template<class T, int M> constexpr vec<T,M> operator * (const mat<T,M,4> & a, const vec<T,4> & b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2] + a[3]*b[3]; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:804:47: error: ‘mat’ does not name a type
     template<class T, int M, int N> constexpr mat<T,M,1> operator * (const mat<T,M,N> & a, const mat<T,N,1> & b) { return {a*b[0]}; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:805:47: error: ‘mat’ does not name a type
     template<class T, int M, int N> constexpr mat<T,M,2> operator * (const mat<T,M,N> & a, const mat<T,N,2> & b) { return {a*b[0], a*b[1]}; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:806:47: error: ‘mat’ does not name a type
     template<class T, int M, int N> constexpr mat<T,M,3> operator * (const mat<T,M,N> & a, const mat<T,N,3> & b) { return {a*b[0], a*b[1], a*b[2]}; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:807:47: error: ‘mat’ does not name a type
     template<class T, int M, int N> constexpr mat<T,M,4> operator * (const mat<T,M,N> & a, const mat<T,N,4> & b) { return {a*b[0], a*b[1], a*b[2], a*b[3]}; }
                                               ^~~
/usr/local/include/linalg-v3/linalg.h:810:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,1> diagonal(const mat<T,1,1> & a) { return {a[0][0]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:811:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,2> diagonal(const mat<T,2,2> & a) { return {a[0][0], a[1][1]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:812:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3> diagonal(const mat<T,3,3> & a) { return {a[0][0], a[1][1], a[2][2]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:813:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,4> diagonal(const mat<T,4,4> & a) { return {a[0][0], a[1][1], a[2][2], a[3][3]}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:814:54: error: ‘mat’ does not name a type
     template<class T, int N> constexpr T trace(const mat<T,N,N> & a) { return sum(diagonal(a)); }
                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:814:57: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T, int N> constexpr T trace(const mat<T,N,N> & a) { return sum(diagonal(a)); }
                                                         ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::trace(int)’:
/usr/local/include/linalg-v3/linalg.h:814:92: error: ‘a’ was not declared in this scope
     template<class T, int N> constexpr T trace(const mat<T,N,N> & a) { return sum(diagonal(a)); }
                                                                                            ^
/usr/local/include/linalg-v3/linalg.h:814:83: error: there are no arguments to ‘diagonal’ that depend on a template parameter, so a declaration of ‘diagonal’ must be available [-fpermissive]
     template<class T, int N> constexpr T trace(const mat<T,N,N> & a) { return sum(diagonal(a)); }
                                                                                   ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:815:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,1> outerprod(const vec<T,M> & a, const vec<T,1> & b) { return {a*b[0]}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:816:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,2> outerprod(const vec<T,M> & a, const vec<T,2> & b) { return {a*b[0], a*b[1]}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:817:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,3> outerprod(const vec<T,M> & a, const vec<T,3> & b) { return {a*b[0], a*b[1], a*b[2]}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:818:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,4> outerprod(const vec<T,M> & a, const vec<T,4> & b) { return {a*b[0], a*b[1], a*b[2], a*b[3]}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:819:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,1> transpose(const mat<T,1,M> & m) { return {m.row(0)}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:820:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,2> transpose(const mat<T,2,M> & m) { return {m.row(0), m.row(1)}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:821:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,3> transpose(const mat<T,3,M> & m) { return {m.row(0), m.row(1), m.row(2)}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:822:40: error: ‘mat’ does not name a type
     template<class T, int M> constexpr mat<T,M,4> transpose(const mat<T,4,M> & m) { return {m.row(0), m.row(1), m.row(2), m.row(3)}; }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:823:33: error: ‘mat’ does not name a type
     template<class T> constexpr mat<T,1,1> adjugate(const mat<T,1,1> & a) { return {vec<T,1>{1}}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:824:33: error: ‘mat’ does not name a type
     template<class T> constexpr mat<T,2,2> adjugate(const mat<T,2,2> & a) { return {{a[1][1], -a[0][1]}, {-a[1][0], a[0][0]}}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:825:33: error: ‘mat’ does not name a type
     template<class T> constexpr mat<T,3,3> adjugate(const mat<T,3,3> & a)
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:831:33: error: ‘mat’ does not name a type
     template<class T> constexpr mat<T,4,4> adjugate(const mat<T,4,4> & a)
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:850:40: error: ‘mat’ does not name a type
     template<class T, int N> constexpr mat<T,N,N> comatrix(const mat<T,N,N> & a) { return transpose(adjugate(a)); }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:851:53: error: ‘mat’ does not name a type
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:851:56: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                                        ^
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::determinant(int)’:
/usr/local/include/linalg-v3/linalg.h:851:78: error: ‘a’ was not declared in this scope
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                                                              ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:852:53: error: ‘mat’ does not name a type
     template<class T> constexpr T determinant(const mat<T,2,2> & a) { return a[0][0]*a[1][1] - a[0][1]*a[1][0]; }
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:852:56: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T determinant(const mat<T,2,2> & a) { return a[0][0]*a[1][1] - a[0][1]*a[1][0]; }
                                                        ^
/usr/local/include/linalg-v3/linalg.h:852:67: error: ‘constexpr T ralgo::determinant(int)’ conflicts with a previous declaration
     template<class T> constexpr T determinant(const mat<T,2,2> & a) { return a[0][0]*a[1][1] - a[0][1]*a[1][0]; }
                                                                   ^
/usr/local/include/linalg-v3/linalg.h:851:35: note: previous declaration ‘constexpr T ralgo::determinant(int)’
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::determinant(int)’:
/usr/local/include/linalg-v3/linalg.h:852:78: error: ‘a’ was not declared in this scope
     template<class T> constexpr T determinant(const mat<T,2,2> & a) { return a[0][0]*a[1][1] - a[0][1]*a[1][0]; }
                                                                              ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:853:53: error: ‘mat’ does not name a type
     template<class T> constexpr T determinant(const mat<T,3,3> & a) { return a[0][0]*(a[1][1]*a[2][2] - a[2][1]*a[1][2]) + a[0][1]*(a[1][2]*a[2][0] - a[2][2]*a[1][0]) + a[0][2]*(a[1][0]*a[2][1] - a[2][0]*a[1][1]); }
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:853:56: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T determinant(const mat<T,3,3> & a) { return a[0][0]*(a[1][1]*a[2][2] - a[2][1]*a[1][2]) + a[0][1]*(a[1][2]*a[2][0] - a[2][2]*a[1][0]) + a[0][2]*(a[1][0]*a[2][1] - a[2][0]*a[1][1]); }
                                                        ^
/usr/local/include/linalg-v3/linalg.h:853:67: error: ‘constexpr T ralgo::determinant(int)’ conflicts with a previous declaration
     template<class T> constexpr T determinant(const mat<T,3,3> & a) { return a[0][0]*(a[1][1]*a[2][2] - a[2][1]*a[1][2]) + a[0][1]*(a[1][2]*a[2][0] - a[2][2]*a[1][0]) + a[0][2]*(a[1][0]*a[2][1] - a[2][0]*a[1][1]); }
                                                                   ^
/usr/local/include/linalg-v3/linalg.h:851:35: note: previous declaration ‘constexpr T ralgo::determinant(int)’
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::determinant(int)’:
/usr/local/include/linalg-v3/linalg.h:853:78: error: ‘a’ was not declared in this scope
     template<class T> constexpr T determinant(const mat<T,3,3> & a) { return a[0][0]*(a[1][1]*a[2][2] - a[2][1]*a[1][2]) + a[0][1]*(a[1][2]*a[2][0] - a[2][2]*a[1][0]) + a[0][2]*(a[1][0]*a[2][1] - a[2][0]*a[1][1]); }
                                                                              ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:854:53: error: ‘mat’ does not name a type
     template<class T> constexpr T determinant(const mat<T,4,4> & a)
                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:854:56: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T determinant(const mat<T,4,4> & a)
                                                        ^
/usr/local/include/linalg-v3/linalg.h:854:67: error: ‘constexpr T ralgo::determinant(int)’ conflicts with a previous declaration
     template<class T> constexpr T determinant(const mat<T,4,4> & a)
                                                                   ^
/usr/local/include/linalg-v3/linalg.h:851:35: note: previous declaration ‘constexpr T ralgo::determinant(int)’
     template<class T> constexpr T determinant(const mat<T,1,1> & a) { return a[0][0]; }
                                   ^~~~~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::determinant(int)’:
/usr/local/include/linalg-v3/linalg.h:856:16: error: ‘a’ was not declared in this scope
         return a[0][0]*(a[1][1]*a[2][2]*a[3][3] + a[3][1]*a[1][2]*a[2][3] + a[2][1]*a[3][2]*a[1][3] - a[1][1]*a[3][2]*a[2][3] - a[2][1]*a[1][2]*a[3][3] - a[3][1]*a[2][2]*a[1][3])
                ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:861:40: error: ‘mat’ does not name a type
     template<class T, int N> constexpr mat<T,N,N> inverse(const mat<T,N,N> & a) { return adjugate(a)/determinant(a); }
                                        ^~~
/usr/local/include/linalg-v3/linalg.h:868:33: error: ‘quat’ does not name a type
     template<class T> constexpr quat<T> operator * (const quat<T> & a, const quat<T> & b) { return {a.x*b.w+a.w*b.x+a.y*b.z-a.z*b.y, a.y*b.w+a.w*b.y+a.z*b.x-a.x*b.z, a.z*b.w+a.w*b.z+a.x*b.y-a.y*b.x, a.w*b.w-a.x*b.x-a.y*b.y-a.z*b.z}; }
                                 ^~~~
/usr/local/include/linalg-v3/linalg.h:871:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           exp      (const quat<T> & q)                         { const auto v = q.xyz(); const auto vv = length(v); return std::exp(q.w)*quat<T>{v * (vv > 0 ? std::sin(vv)/vv : 0), std::cos(vv)}; }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:872:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           log      (const quat<T> & q)                         { const auto v = q.xyz(); const auto vv = length(v), qq = length(q); return {v * (vv > 0 ? std::acos(q.w/qq)/vv : 0), std::log(qq)}; }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:873:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           pow      (const quat<T> & q, const T & p)            { const auto v = q.xyz(); const auto vv = length(v), qq = length(q), th = std::acos(q.w/qq); return std::pow(qq,p)*quat<T>{v * (vv > 0 ? std::sin(p*th)/vv : 0), std::cos(p*th)}; }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:874:33: error: ‘quat’ does not name a type
     template<class T> constexpr quat<T> conjugate(const quat<T> & a)                         { return {-a.x, -a.y, -a.z, a.w}; }
                                 ^~~~
/usr/local/include/linalg-v3/linalg.h:875:57: error: ‘quat’ does not name a type
     template<class T> constexpr T       dot      (const quat<T> & a, const quat<T> & b)      { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }
                                                         ^~~~
/usr/local/include/linalg-v3/linalg.h:875:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T       dot      (const quat<T> & a, const quat<T> & b)      { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:875:87: error: ‘constexpr T ralgo::dot(int)’ conflicts with a previous declaration
     template<class T> constexpr T       dot      (const quat<T> & a, const quat<T> & b)      { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:784:42: note: previous declaration ‘constexpr T ralgo::dot(int)’
     template<class T, int M> constexpr T dot      (const vec<T,M> & a, const vec<T,M> & b)      { return sum(a*b); }
                                          ^~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::dot(int)’:
/usr/local/include/linalg-v3/linalg.h:875:103: error: ‘a’ was not declared in this scope
     template<class T> constexpr T       dot      (const quat<T> & a, const quat<T> & b)      { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }
                                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:875:107: error: ‘b’ was not declared in this scope
     template<class T> constexpr T       dot      (const quat<T> & a, const quat<T> & b)      { return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }
                                                                                                           ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:876:57: error: ‘quat’ does not name a type
     template<class T> constexpr T       length2  (const quat<T> & a)                         { return dot(a,a); }
                                                         ^~~~
/usr/local/include/linalg-v3/linalg.h:876:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> constexpr T       length2  (const quat<T> & a)                         { return dot(a,a); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:876:68: error: ‘constexpr T ralgo::length2(int)’ conflicts with a previous declaration
     template<class T> constexpr T       length2  (const quat<T> & a)                         { return dot(a,a); }
                                                                    ^
/usr/local/include/linalg-v3/linalg.h:785:42: note: previous declaration ‘constexpr T ralgo::length2(int)’
     template<class T, int M> constexpr T length2  (const vec<T,M> & a)                          { return dot(a,a); }
                                          ^~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘constexpr T ralgo::length2(int)’:
/usr/local/include/linalg-v3/linalg.h:876:107: error: ‘a’ was not declared in this scope
     template<class T> constexpr T       length2  (const quat<T> & a)                         { return dot(a,a); }
                                                                                                           ^
/usr/local/include/linalg-v3/linalg.h:876:103: error: there are no arguments to ‘dot’ that depend on a template parameter, so a declaration of ‘dot’ must be available [-fpermissive]
     template<class T> constexpr T       length2  (const quat<T> & a)                         { return dot(a,a); }
                                                                                                       ^~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:877:57: error: ‘quat’ does not name a type
     template<class T> T                 length   (const quat<T> & a)                         { return std::sqrt(length2(a)); }
                                                         ^~~~
/usr/local/include/linalg-v3/linalg.h:877:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> T                 length   (const quat<T> & a)                         { return std::sqrt(length2(a)); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:877:68: error: ‘T ralgo::length(int)’ conflicts with a previous declaration
     template<class T> T                 length   (const quat<T> & a)                         { return std::sqrt(length2(a)); }
                                                                    ^
/usr/local/include/linalg-v3/linalg.h:786:42: note: previous declaration ‘T ralgo::length(int)’
     template<class T, int M> T           length   (const vec<T,M> & a)                          { return std::sqrt(length2(a)); }
                                          ^~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::length(int)’:
/usr/local/include/linalg-v3/linalg.h:877:121: error: ‘a’ was not declared in this scope
     template<class T> T                 length   (const quat<T> & a)                         { return std::sqrt(length2(a)); }
                                                                                                                         ^
/usr/local/include/linalg-v3/linalg.h:877:113: error: there are no arguments to ‘length2’ that depend on a template parameter, so a declaration of ‘length2’ must be available [-fpermissive]
     template<class T> T                 length   (const quat<T> & a)                         { return std::sqrt(length2(a)); }
                                                                                                                 ^~~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:878:33: error: ‘quat’ does not name a type
     template<class T> constexpr quat<T> inverse  (const quat<T> & a)                         { return conjugate(a) / length2(a); }
                                 ^~~~
/usr/local/include/linalg-v3/linalg.h:879:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           normalize(const quat<T> & a)                         { return a / length(a); }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:880:57: error: ‘quat’ does not name a type
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                         ^~~~
/usr/local/include/linalg-v3/linalg.h:880:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                             ^
/usr/local/include/linalg-v3/linalg.h:880:87: error: ‘T ralgo::uangle(int)’ conflicts with a previous declaration
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:790:42: note: previous declaration ‘T ralgo::uangle(int)’
     template<class T, int M> T           uangle   (const vec<T,M> & a, const vec<T,M> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                          ^~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::uangle(int)’:
/usr/local/include/linalg-v3/linalg.h:880:104: error: ‘a’ was not declared in this scope
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:880:106: error: ‘b’ was not declared in this scope
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h:880:100: error: there are no arguments to ‘dot’ that depend on a template parameter, so a declaration of ‘dot’ must be available [-fpermissive]
     template<class T> T                 uangle   (const quat<T> & a, const quat<T> & b)      { T d=dot(a,b); return d > 1 ? 0 : std::acos(d < -1 ? -1 : d); }
                                                                                                    ^~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:881:33: error: ‘quat’ does not name a type
     template<class T> constexpr quat<T> lerp     (const quat<T> & a, const quat<T> & b, T t) { return a*(1-t) + b*t; }
                                 ^~~~
/usr/local/include/linalg-v3/linalg.h:882:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           nlerp    (const quat<T> & a, const quat<T> & b, T t) { return normalize(lerp(a,b,t)); }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:883:23: error: ‘quat’ does not name a type
     template<class T> quat<T>           slerp    (const quat<T> & a, const quat<T> & b, T t) { T th=uangle(a,b); return th == 0 ? a : a*(std::sin(th*(1-t))/std::sin(th)) + b*(std::sin(th*t)/std::sin(th)); }
                       ^~~~
/usr/local/include/linalg-v3/linalg.h:886:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3>   qxdir (const quat<T> & q)                          { return {q.w*q.w+q.x*q.x-q.y*q.y-q.z*q.z, (q.x*q.y+q.z*q.w)*2, (q.z*q.x-q.y*q.w)*2}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:887:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3>   qydir (const quat<T> & q)                          { return {(q.x*q.y-q.z*q.w)*2, q.w*q.w-q.x*q.x+q.y*q.y-q.z*q.z, (q.y*q.z+q.x*q.w)*2}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:888:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3>   qzdir (const quat<T> & q)                          { return {(q.z*q.x+q.y*q.w)*2, (q.y*q.z-q.x*q.w)*2, q.w*q.w-q.x*q.x-q.y*q.y+q.z*q.z}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:889:33: error: ‘mat’ does not name a type
     template<class T> constexpr mat<T,3,3> qmat  (const quat<T> & q)                          { return {qxdir(q), qydir(q), qzdir(q)}; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:890:33: error: ‘vec’ does not name a type
     template<class T> constexpr vec<T,3>   qrot  (const quat<T> & q, const vec<T,3> & v)      { return qxdir(q)*v.x + qydir(q)*v.y + qzdir(q)*v.z; }
                                 ^~~
/usr/local/include/linalg-v3/linalg.h:891:57: error: ‘quat’ does not name a type
     template<class T> T                    qangle(const quat<T> & q)                          { return std::atan2(length(q.xyz()), q.w)*2; }
                                                         ^~~~
/usr/local/include/linalg-v3/linalg.h:891:61: error: expected ‘,’ or ‘...’ before ‘<’ token
     template<class T> T                    qangle(const quat<T> & q)                          { return std::atan2(length(q.xyz()), q.w)*2; }
                                                             ^
/usr/local/include/linalg-v3/linalg.h: In function ‘T ralgo::qangle(int)’:
/usr/local/include/linalg-v3/linalg.h:891:122: error: ‘q’ was not declared in this scope
     template<class T> T                    qangle(const quat<T> & q)                          { return std::atan2(length(q.xyz()), q.w)*2; }
                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h:891:115: error: there are no arguments to ‘length’ that depend on a template parameter, so a declaration of ‘length’ must be available [-fpermissive]
     template<class T> T                    qangle(const quat<T> & q)                          { return std::atan2(length(q.xyz()), q.w)*2; }
                                                                                                                   ^~~~~~
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:892:23: error: ‘vec’ does not name a type
     template<class T> vec<T,3>             qaxis (const quat<T> & q)                          { return normalize(q.xyz()); }
                       ^~~
/usr/local/include/linalg-v3/linalg.h:900:22: error: ‘vec’ does not name a type
         using float1=vec<float,1>; using double1=vec<double,1>; using int1=vec<int,1>; using uint1=vec<unsigned int,1>; using bool1=vec<bool,1>;
                      ^~~
/usr/local/include/linalg-v3/linalg.h:900:50: error: ‘vec’ does not name a type
         using float1=vec<float,1>; using double1=vec<double,1>; using int1=vec<int,1>; using uint1=vec<unsigned int,1>; using bool1=vec<bool,1>;
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:900:76: error: ‘vec’ does not name a type
         using float1=vec<float,1>; using double1=vec<double,1>; using int1=vec<int,1>; using uint1=vec<unsigned int,1>; using bool1=vec<bool,1>;
                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:900:100: error: ‘vec’ does not name a type
         using float1=vec<float,1>; using double1=vec<double,1>; using int1=vec<int,1>; using uint1=vec<unsigned int,1>; using bool1=vec<bool,1>;
                                                                                                    ^~~
/usr/local/include/linalg-v3/linalg.h:900:133: error: ‘vec’ does not name a type
         using float1=vec<float,1>; using double1=vec<double,1>; using int1=vec<int,1>; using uint1=vec<unsigned int,1>; using bool1=vec<bool,1>;
                                                                                                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:901:22: error: ‘vec’ does not name a type
         using float2=vec<float,2>; using double2=vec<double,2>; using int2=vec<int,2>; using uint2=vec<unsigned int,2>; using bool2=vec<bool,2>;
                      ^~~
/usr/local/include/linalg-v3/linalg.h:901:50: error: ‘vec’ does not name a type
         using float2=vec<float,2>; using double2=vec<double,2>; using int2=vec<int,2>; using uint2=vec<unsigned int,2>; using bool2=vec<bool,2>;
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:901:76: error: ‘vec’ does not name a type
         using float2=vec<float,2>; using double2=vec<double,2>; using int2=vec<int,2>; using uint2=vec<unsigned int,2>; using bool2=vec<bool,2>;
                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:901:100: error: ‘vec’ does not name a type
         using float2=vec<float,2>; using double2=vec<double,2>; using int2=vec<int,2>; using uint2=vec<unsigned int,2>; using bool2=vec<bool,2>;
                                                                                                    ^~~
/usr/local/include/linalg-v3/linalg.h:901:133: error: ‘vec’ does not name a type
         using float2=vec<float,2>; using double2=vec<double,2>; using int2=vec<int,2>; using uint2=vec<unsigned int,2>; using bool2=vec<bool,2>;
                                                                                                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:902:22: error: ‘vec’ does not name a type
         using float3=vec<float,3>; using double3=vec<double,3>; using int3=vec<int,3>; using uint3=vec<unsigned int,3>; using bool3=vec<bool,3>;
                      ^~~
/usr/local/include/linalg-v3/linalg.h:902:50: error: ‘vec’ does not name a type
         using float3=vec<float,3>; using double3=vec<double,3>; using int3=vec<int,3>; using uint3=vec<unsigned int,3>; using bool3=vec<bool,3>;
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:902:76: error: ‘vec’ does not name a type
         using float3=vec<float,3>; using double3=vec<double,3>; using int3=vec<int,3>; using uint3=vec<unsigned int,3>; using bool3=vec<bool,3>;
                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:902:100: error: ‘vec’ does not name a type
         using float3=vec<float,3>; using double3=vec<double,3>; using int3=vec<int,3>; using uint3=vec<unsigned int,3>; using bool3=vec<bool,3>;
                                                                                                    ^~~
/usr/local/include/linalg-v3/linalg.h:902:133: error: ‘vec’ does not name a type
         using float3=vec<float,3>; using double3=vec<double,3>; using int3=vec<int,3>; using uint3=vec<unsigned int,3>; using bool3=vec<bool,3>;
                                                                                                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:903:22: error: ‘vec’ does not name a type
         using float4=vec<float,4>; using double4=vec<double,4>; using int4=vec<int,4>; using uint4=vec<unsigned int,4>; using bool4=vec<bool,4>;
                      ^~~
/usr/local/include/linalg-v3/linalg.h:903:50: error: ‘vec’ does not name a type
         using float4=vec<float,4>; using double4=vec<double,4>; using int4=vec<int,4>; using uint4=vec<unsigned int,4>; using bool4=vec<bool,4>;
                                                  ^~~
/usr/local/include/linalg-v3/linalg.h:903:76: error: ‘vec’ does not name a type
         using float4=vec<float,4>; using double4=vec<double,4>; using int4=vec<int,4>; using uint4=vec<unsigned int,4>; using bool4=vec<bool,4>;
                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:903:100: error: ‘vec’ does not name a type
         using float4=vec<float,4>; using double4=vec<double,4>; using int4=vec<int,4>; using uint4=vec<unsigned int,4>; using bool4=vec<bool,4>;
                                                                                                    ^~~
/usr/local/include/linalg-v3/linalg.h:903:133: error: ‘vec’ does not name a type
         using float4=vec<float,4>; using double4=vec<double,4>; using int4=vec<int,4>; using uint4=vec<unsigned int,4>; using bool4=vec<bool,4>;
                                                                                                                                     ^~~
/usr/local/include/linalg-v3/linalg.h:904:24: error: ‘mat’ does not name a type
         using float1x1=mat<float,1,1>; using double1x1=mat<double,1,1>; using int1x1=mat<int,1,1>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:904:56: error: ‘mat’ does not name a type
         using float1x1=mat<float,1,1>; using double1x1=mat<double,1,1>; using int1x1=mat<int,1,1>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:904:86: error: ‘mat’ does not name a type
         using float1x1=mat<float,1,1>; using double1x1=mat<double,1,1>; using int1x1=mat<int,1,1>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:905:24: error: ‘mat’ does not name a type
         using float1x2=mat<float,1,2>; using double1x2=mat<double,1,2>; using int1x2=mat<int,1,2>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:905:56: error: ‘mat’ does not name a type
         using float1x2=mat<float,1,2>; using double1x2=mat<double,1,2>; using int1x2=mat<int,1,2>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:905:86: error: ‘mat’ does not name a type
         using float1x2=mat<float,1,2>; using double1x2=mat<double,1,2>; using int1x2=mat<int,1,2>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:906:24: error: ‘mat’ does not name a type
         using float1x3=mat<float,1,3>; using double1x3=mat<double,1,3>; using int1x3=mat<int,1,3>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:906:56: error: ‘mat’ does not name a type
         using float1x3=mat<float,1,3>; using double1x3=mat<double,1,3>; using int1x3=mat<int,1,3>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:906:86: error: ‘mat’ does not name a type
         using float1x3=mat<float,1,3>; using double1x3=mat<double,1,3>; using int1x3=mat<int,1,3>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:907:24: error: ‘mat’ does not name a type
         using float1x4=mat<float,1,4>; using double1x4=mat<double,1,4>; using int1x4=mat<int,1,4>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:907:56: error: ‘mat’ does not name a type
         using float1x4=mat<float,1,4>; using double1x4=mat<double,1,4>; using int1x4=mat<int,1,4>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:907:86: error: ‘mat’ does not name a type
         using float1x4=mat<float,1,4>; using double1x4=mat<double,1,4>; using int1x4=mat<int,1,4>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:908:24: error: ‘mat’ does not name a type
         using float2x1=mat<float,2,1>; using double2x1=mat<double,2,1>; using int2x1=mat<int,2,1>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:908:56: error: ‘mat’ does not name a type
         using float2x1=mat<float,2,1>; using double2x1=mat<double,2,1>; using int2x1=mat<int,2,1>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:908:86: error: ‘mat’ does not name a type
         using float2x1=mat<float,2,1>; using double2x1=mat<double,2,1>; using int2x1=mat<int,2,1>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:909:24: error: ‘mat’ does not name a type
         using float2x2=mat<float,2,2>; using double2x2=mat<double,2,2>; using int2x2=mat<int,2,2>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:909:56: error: ‘mat’ does not name a type
         using float2x2=mat<float,2,2>; using double2x2=mat<double,2,2>; using int2x2=mat<int,2,2>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:909:86: error: ‘mat’ does not name a type
         using float2x2=mat<float,2,2>; using double2x2=mat<double,2,2>; using int2x2=mat<int,2,2>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:910:24: error: ‘mat’ does not name a type
         using float2x3=mat<float,2,3>; using double2x3=mat<double,2,3>; using int2x3=mat<int,2,3>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:910:56: error: ‘mat’ does not name a type
         using float2x3=mat<float,2,3>; using double2x3=mat<double,2,3>; using int2x3=mat<int,2,3>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:910:86: error: ‘mat’ does not name a type
         using float2x3=mat<float,2,3>; using double2x3=mat<double,2,3>; using int2x3=mat<int,2,3>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:911:24: error: ‘mat’ does not name a type
         using float2x4=mat<float,2,4>; using double2x4=mat<double,2,4>; using int2x4=mat<int,2,4>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:911:56: error: ‘mat’ does not name a type
         using float2x4=mat<float,2,4>; using double2x4=mat<double,2,4>; using int2x4=mat<int,2,4>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:911:86: error: ‘mat’ does not name a type
         using float2x4=mat<float,2,4>; using double2x4=mat<double,2,4>; using int2x4=mat<int,2,4>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:912:24: error: ‘mat’ does not name a type
         using float3x1=mat<float,3,1>; using double3x1=mat<double,3,1>; using int3x1=mat<int,3,1>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:912:56: error: ‘mat’ does not name a type
         using float3x1=mat<float,3,1>; using double3x1=mat<double,3,1>; using int3x1=mat<int,3,1>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:912:86: error: ‘mat’ does not name a type
         using float3x1=mat<float,3,1>; using double3x1=mat<double,3,1>; using int3x1=mat<int,3,1>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:913:24: error: ‘mat’ does not name a type
         using float3x2=mat<float,3,2>; using double3x2=mat<double,3,2>; using int3x2=mat<int,3,2>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:913:56: error: ‘mat’ does not name a type
         using float3x2=mat<float,3,2>; using double3x2=mat<double,3,2>; using int3x2=mat<int,3,2>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:913:86: error: ‘mat’ does not name a type
         using float3x2=mat<float,3,2>; using double3x2=mat<double,3,2>; using int3x2=mat<int,3,2>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:914:24: error: ‘mat’ does not name a type
         using float3x3=mat<float,3,3>; using double3x3=mat<double,3,3>; using int3x3=mat<int,3,3>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:914:56: error: ‘mat’ does not name a type
         using float3x3=mat<float,3,3>; using double3x3=mat<double,3,3>; using int3x3=mat<int,3,3>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:914:86: error: ‘mat’ does not name a type
         using float3x3=mat<float,3,3>; using double3x3=mat<double,3,3>; using int3x3=mat<int,3,3>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:915:24: error: ‘mat’ does not name a type
         using float3x4=mat<float,3,4>; using double3x4=mat<double,3,4>; using int3x4=mat<int,3,4>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:915:56: error: ‘mat’ does not name a type
         using float3x4=mat<float,3,4>; using double3x4=mat<double,3,4>; using int3x4=mat<int,3,4>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:915:86: error: ‘mat’ does not name a type
         using float3x4=mat<float,3,4>; using double3x4=mat<double,3,4>; using int3x4=mat<int,3,4>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:916:24: error: ‘mat’ does not name a type
         using float4x1=mat<float,4,1>; using double4x1=mat<double,4,1>; using int4x1=mat<int,4,1>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:916:56: error: ‘mat’ does not name a type
         using float4x1=mat<float,4,1>; using double4x1=mat<double,4,1>; using int4x1=mat<int,4,1>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:916:86: error: ‘mat’ does not name a type
         using float4x1=mat<float,4,1>; using double4x1=mat<double,4,1>; using int4x1=mat<int,4,1>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:917:24: error: ‘mat’ does not name a type
         using float4x2=mat<float,4,2>; using double4x2=mat<double,4,2>; using int4x2=mat<int,4,2>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:917:56: error: ‘mat’ does not name a type
         using float4x2=mat<float,4,2>; using double4x2=mat<double,4,2>; using int4x2=mat<int,4,2>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:917:86: error: ‘mat’ does not name a type
         using float4x2=mat<float,4,2>; using double4x2=mat<double,4,2>; using int4x2=mat<int,4,2>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:918:24: error: ‘mat’ does not name a type
         using float4x3=mat<float,4,3>; using double4x3=mat<double,4,3>; using int4x3=mat<int,4,3>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:918:56: error: ‘mat’ does not name a type
         using float4x3=mat<float,4,3>; using double4x3=mat<double,4,3>; using int4x3=mat<int,4,3>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:918:86: error: ‘mat’ does not name a type
         using float4x3=mat<float,4,3>; using double4x3=mat<double,4,3>; using int4x3=mat<int,4,3>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:919:24: error: ‘mat’ does not name a type
         using float4x4=mat<float,4,4>; using double4x4=mat<double,4,4>; using int4x4=mat<int,4,4>;
                        ^~~
/usr/local/include/linalg-v3/linalg.h:919:56: error: ‘mat’ does not name a type
         using float4x4=mat<float,4,4>; using double4x4=mat<double,4,4>; using int4x4=mat<int,4,4>;
                                                        ^~~
/usr/local/include/linalg-v3/linalg.h:919:86: error: ‘mat’ does not name a type
         using float4x4=mat<float,4,4>; using double4x4=mat<double,4,4>; using int4x4=mat<int,4,4>;
                                                                                      ^~~
/usr/local/include/linalg-v3/linalg.h:920:21: error: ‘quat’ does not name a type
         using quatf=quat<float>; using quatd=quat<double>; using quati=quat<int>;
                     ^~~~
/usr/local/include/linalg-v3/linalg.h:920:46: error: ‘quat’ does not name a type
         using quatf=quat<float>; using quatd=quat<double>; using quati=quat<int>;
                                              ^~~~
/usr/local/include/linalg-v3/linalg.h:920:72: error: ‘quat’ does not name a type
         using quatf=quat<float>; using quatd=quat<double>; using quati=quat<int>;
                                                                        ^~~~
/usr/local/include/linalg-v3/linalg.h:930:108: error: ‘vec’ does not name a type
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:930:111: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:930:145: error: ‘v’ was not declared in this scope
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:931:108: error: ‘vec’ does not name a type
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,2> & v) { return out << '{' << v[0] << ',' << v[1] << '}'; }
                                                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:931:111: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,2> & v) { return out << '{' << v[0] << ',' << v[1] << '}'; }
                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:931:120: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,2> & v) { return out << '{' << v[0] << ',' << v[1] << '}'; }
                                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:931:145: error: ‘v’ was not declared in this scope
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,2> & v) { return out << '{' << v[0] << ',' << v[1] << '}'; }
                                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:932:108: error: ‘vec’ does not name a type
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,3> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << '}'; }
                                                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:932:111: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,3> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << '}'; }
                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:932:120: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,3> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << '}'; }
                                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:932:145: error: ‘v’ was not declared in this scope
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,3> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << '}'; }
                                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:933:108: error: ‘vec’ does not name a type
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,4> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << ',' << v[3] << '}'; }
                                                                                                            ^~~
/usr/local/include/linalg-v3/linalg.h:933:111: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,4> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << ',' << v[3] << '}'; }
                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:933:120: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,4> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << ',' << v[3] << '}'; }
                                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:933:145: error: ‘v’ was not declared in this scope
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,4> & v) { return out << '{' << v[0] << ',' << v[1] << ',' << v[2] << ',' << v[3] << '}'; }
                                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:934:115: error: ‘mat’ does not name a type
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,1> & m) { return out << '{' << m[0] << '}'; }
                                                                                                                   ^~~
/usr/local/include/linalg-v3/linalg.h:934:118: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,1> & m) { return out << '{' << m[0] << '}'; }
                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:934:129: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,1> & m) { return out << '{' << m[0] << '}'; }
                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:934:154: error: ‘m’ was not declared in this scope
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,1> & m) { return out << '{' << m[0] << '}'; }
                                                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:935:115: error: ‘mat’ does not name a type
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,2> & m) { return out << '{' << m[0] << ',' << m[1] << '}'; }
                                                                                                                   ^~~
/usr/local/include/linalg-v3/linalg.h:935:118: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,2> & m) { return out << '{' << m[0] << ',' << m[1] << '}'; }
                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:935:129: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,2> & m) { return out << '{' << m[0] << ',' << m[1] << '}'; }
                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:935:154: error: ‘m’ was not declared in this scope
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,2> & m) { return out << '{' << m[0] << ',' << m[1] << '}'; }
                                                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:936:115: error: ‘mat’ does not name a type
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,3> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << '}'; }
                                                                                                                   ^~~
/usr/local/include/linalg-v3/linalg.h:936:118: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,3> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << '}'; }
                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:936:129: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,3> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << '}'; }
                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:936:154: error: ‘m’ was not declared in this scope
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,3> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << '}'; }
                                                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:937:115: error: ‘mat’ does not name a type
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,4> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << ',' << m[3] << '}'; }
                                                                                                                   ^~~
/usr/local/include/linalg-v3/linalg.h:937:118: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,4> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << ',' << m[3] << '}'; }
                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:937:129: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,4> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << ',' << m[3] << '}'; }
                                                                                                                                 ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:937:154: error: ‘m’ was not declared in this scope
         template<class C, class T, int M> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const mat<T,M,4> & m) { return out << '{' << m[0] << ',' << m[1] << ',' << m[2] << ',' << m[3] << '}'; }
                                                                                                                                                          ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:938:108: error: ‘quat’ does not name a type
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const quat<T> & q) { return out << '{' << q.x << ',' << q.y << ',' << q.z << ',' << q.w << '}'; }
                                                                                                            ^~~~
/usr/local/include/linalg-v3/linalg.h:938:112: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const quat<T> & q) { return out << '{' << q.x << ',' << q.y << ',' << q.z << ',' << q.w << '}'; }
                                                                                                                ^
/usr/local/include/linalg-v3/linalg.h:938:119: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const quat<T> & q) { return out << '{' << q.x << ',' << q.y << ',' << q.z << ',' << q.w << '}'; }
                                                                                                                       ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:938:144: error: ‘q’ was not declared in this scope
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const quat<T> & q) { return out << '{' << q.x << ',' << q.y << ',' << q.z << ',' << q.w << '}'; }
                                                                                                                                                ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:939:127: error: ‘_lswizzle’ does not name a type
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:939:136: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:939:150: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:939:154: error: ‘vec’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:939:154: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:939:159: error: expected primary-expression before ‘,’ token
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:939:174: error: ‘v’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                                              ^
/usr/local/include/linalg-v3/linalg.h:939:178: error: ‘s’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _lswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                                                  ^
/usr/local/include/linalg-v3/linalg.h: At global scope:
/usr/local/include/linalg-v3/linalg.h:940:127: error: ‘_rswizzle’ does not name a type
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                               ^~~~~~~~~
/usr/local/include/linalg-v3/linalg.h:940:136: error: expected ‘,’ or ‘...’ before ‘<’ token
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                        ^
/usr/local/include/linalg-v3/linalg.h:940:150: error: ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’ conflicts with a previous declaration
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                      ^
/usr/local/include/linalg-v3/linalg.h:930:60: note: previous declaration ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’
         template<class C, class T> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const vec<T,1> & v) { return out << '{' << v[0] << '}'; }
                                                            ^~~~~~~~
/usr/local/include/linalg-v3/linalg.h: In function ‘std::basic_ostream<C>& ralgo::operator<<(std::basic_ostream<C>&, int)’:
/usr/local/include/linalg-v3/linalg.h:940:154: error: ‘vec’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                          ^~~
/usr/local/include/linalg-v3/linalg.h:940:154: note: suggested alternative:
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:71:37: note:   ‘linalg::vec’
     template<class T, int M> struct vec;
                                     ^~~
In file included from /home/mirmik/project/rabbit/./rabbit/linalg.h:4:0,
                 from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/usr/local/include/linalg-v3/linalg.h:940:159: error: expected primary-expression before ‘,’ token
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                               ^
/usr/local/include/linalg-v3/linalg.h:940:174: error: ‘v’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                                              ^
/usr/local/include/linalg-v3/linalg.h:940:178: error: ‘s’ was not declared in this scope
         template<class C, class T, class A, int... I> std::basic_ostream<C> & operator << (std::basic_ostream<C> & out, const _rswizzle<T,A,I...> & s) { vec<T,sizeof...(I)> v = s; return out << v; }
                                                                                                                                                                                  ^
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/linalg.h: At global scope:
/home/mirmik/project/rabbit/./rabbit/linalg.h:13:8: error: conflicting declaration of template ‘template<class T> struct rabbit::pnt2’
  class pnt2 : public linalg::vec<T,2>
        ^~~~
/home/mirmik/project/rabbit/./rabbit/linalg.h:9:27: note: previous declaration ‘template<class T> class rabbit::pnt2’
  template <class T> class pnt2;
                           ^~~~
/home/mirmik/project/rabbit/./rabbit/linalg.h:35:8: error: conflicting declaration of template ‘template<class T> struct rabbit::vec2’
  class vec2 : public linalg::vec<T,2>
        ^~~~
/home/mirmik/project/rabbit/./rabbit/linalg.h:10:27: note: previous declaration ‘template<class T> class rabbit::vec2’
  template <class T> class vec2;
                           ^~~~
/home/mirmik/project/rabbit/./rabbit/linalg.h:84:2: error: ‘pnt2’ does not name a type
  pnt2<T> pnt2<T>::operator +(const vec2<T>& oth)
  ^~~~
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/interval.h:141:3: error: ‘interval_union’ does not name a type
   interval_union<T> intersect(interval oth) const
   ^~~~~~~~~~~~~~
/home/mirmik/project/rabbit/./rabbit/interval.h:148:3: error: ‘interval_union’ does not name a type
   interval_union<T> combine(interval oth) const
   ^~~~~~~~~~~~~~
/home/mirmik/project/rabbit/./rabbit/interval.h:157:3: error: ‘interval_union’ does not name a type
   interval_union<T> difference(interval oth) const
   ^~~~~~~~~~~~~~
/home/mirmik/project/rabbit/./rabbit/interval.h:178:3: error: ‘interval_union’ does not name a type
   interval_union<T> divide(T pnct)
   ^~~~~~~~~~~~~~
/home/mirmik/project/rabbit/./rabbit/interval.h:199:8: error: conflicting declaration of template ‘template<class T> struct rabbit::interval_union’
  class interval_union
        ^~~~~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/interval.h:16:30: note: previous declaration ‘template<class T> struct rabbit::interval_union’
  template<typename T> struct interval_union;
                              ^~~~~~~~~~~~~~
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:5:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/interval.h:481:44: error: expected template-name before ‘<’ token
  struct directed_interval : public interval<T>
                                            ^
/home/mirmik/project/rabbit/./rabbit/interval.h:481:44: error: expected ‘{’ before ‘<’ token
In file included from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6:0,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:20:36: error: expected template-name before ‘<’ token
  struct line_curve2 : public curve2<T>
                                    ^
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:20:36: error: expected ‘{’ before ‘<’ token
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:46:39: error: expected template-name before ‘<’ token
  struct ellipse_curve2 : public curve2<T>
                                       ^
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:46:39: error: expected ‘{’ before ‘<’ token
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:111:39: error: expected template-name before ‘<’ token
  struct bounded_curve2 : public curve2<T>
                                       ^
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:111:39: error: expected ‘{’ before ‘<’ token
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:120:41: error: expected template-name before ‘<’ token
  struct segment2 : public bounded_curve2<T>
                                         ^
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:120:41: error: expected ‘{’ before ‘<’ token
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:134:47: error: expected template-name before ‘<’ token
  struct trimmed_curve2 : public bounded_curve2<T>
                                               ^
/home/mirmik/project/rabbit/./rabbit/geom/curve2.h:134:47: error: expected ‘{’ before ‘<’ token
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:65:11: error: conflicting declaration of template ‘template<class _CharT, class _Traits, class _Alloc> struct std::__cxx11::basic_stringbuf’
     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
           ^~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:96:11: note: previous declaration ‘template<class _CharT, class _Traits, class _Alloc> class std::__cxx11::basic_stringbuf’
     class basic_stringbuf;
           ^~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:65:51: error: expected template-name before ‘<’ token
     class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
                                                   ^
/usr/include/c++/7/sstream:380:11: error: conflicting declaration of template ‘template<class _CharT, class _Traits, class _Alloc> struct std::__cxx11::basic_istringstream’
     class basic_istringstream : public basic_istream<_CharT, _Traits>
           ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:100:11: note: previous declaration ‘template<class _CharT, class _Traits, class _Alloc> class std::__cxx11::basic_istringstream’
     class basic_istringstream;
           ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:380:53: error: expected template-name before ‘<’ token
     class basic_istringstream : public basic_istream<_CharT, _Traits>
                                                     ^
/usr/include/c++/7/sstream:524:11: error: conflicting declaration of template ‘template<class _CharT, class _Traits, class _Alloc> struct std::__cxx11::basic_ostringstream’
     class basic_ostringstream : public basic_ostream<_CharT, _Traits>
           ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:104:11: note: previous declaration ‘template<class _CharT, class _Traits, class _Alloc> class std::__cxx11::basic_ostringstream’
     class basic_ostringstream;
           ^~~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:524:53: error: expected template-name before ‘<’ token
     class basic_ostringstream : public basic_ostream<_CharT, _Traits>
                                                     ^
/usr/include/c++/7/sstream:668:11: error: conflicting declaration of template ‘template<class _CharT, class _Traits, class _Alloc> struct std::__cxx11::basic_stringstream’
     class basic_stringstream : public basic_iostream<_CharT, _Traits>
           ^~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:108:11: note: previous declaration ‘template<class _CharT, class _Traits, class _Alloc> class std::__cxx11::basic_stringstream’
     class basic_stringstream;
           ^~~~~~~~~~~~~~~~~~
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:668:53: error: expected template-name before ‘<’ token
     class basic_stringstream : public basic_iostream<_CharT, _Traits>
                                                     ^
/usr/include/c++/7/sstream:796:10: error: variable or field ‘swap’ declared void
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
          ^~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:796:10: error: ‘basic_stringbuf’ was not declared in this scope
/usr/include/c++/7/sstream:796:10: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:96:11: note:   ‘std::__cxx11::basic_stringbuf’
     class basic_stringbuf;
           ^~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:96:11: note:   ‘std::__cxx11::basic_stringbuf’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:796:32: error: expected primary-expression before ‘,’ token
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
                                ^
/usr/include/c++/7/sstream:796:41: error: expected primary-expression before ‘,’ token
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
                                         ^
/usr/include/c++/7/sstream:796:53: error: expected primary-expression before ‘>’ token
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
                                                     ^
/usr/include/c++/7/sstream:796:56: error: ‘__x’ was not declared in this scope
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
                                                        ^~~
/usr/include/c++/7/sstream:796:56: note: suggested alternative: ‘__N’
     swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
                                                        ^~~
                                                        __N
/usr/include/c++/7/sstream:797:3: error: ‘basic_stringbuf’ was not declared in this scope
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
   ^~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:797:3: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:96:11: note:   ‘std::__cxx11::basic_stringbuf’
     class basic_stringbuf;
           ^~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:96:11: note:   ‘std::__cxx11::basic_stringbuf’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:797:25: error: expected primary-expression before ‘,’ token
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
                         ^
/usr/include/c++/7/sstream:797:34: error: expected primary-expression before ‘,’ token
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
                                  ^
/usr/include/c++/7/sstream:797:46: error: expected primary-expression before ‘>’ token
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
                                              ^
/usr/include/c++/7/sstream:797:49: error: ‘__y’ was not declared in this scope
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
                                                 ^~~
/usr/include/c++/7/sstream:797:49: note: suggested alternative: ‘__yn’
   basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
                                                 ^~~
                                                 __yn
/usr/include/c++/7/sstream:803:10: error: variable or field ‘swap’ declared void
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
          ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:803:10: error: ‘basic_istringstream’ was not declared in this scope
/usr/include/c++/7/sstream:803:10: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:100:11: note:   ‘std::__cxx11::basic_istringstream’
     class basic_istringstream;
           ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:100:11: note:   ‘std::__cxx11::basic_istringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:803:36: error: expected primary-expression before ‘,’ token
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
                                    ^
/usr/include/c++/7/sstream:803:45: error: expected primary-expression before ‘,’ token
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
                                             ^
/usr/include/c++/7/sstream:803:57: error: expected primary-expression before ‘>’ token
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
                                                         ^
/usr/include/c++/7/sstream:803:60: error: ‘__x’ was not declared in this scope
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
                                                            ^~~
/usr/include/c++/7/sstream:803:60: note: suggested alternative: ‘__N’
     swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
                                                            ^~~
                                                            __N
/usr/include/c++/7/sstream:804:3: error: ‘basic_istringstream’ was not declared in this scope
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:804:3: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:100:11: note:   ‘std::__cxx11::basic_istringstream’
     class basic_istringstream;
           ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:100:11: note:   ‘std::__cxx11::basic_istringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:804:29: error: expected primary-expression before ‘,’ token
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
                             ^
/usr/include/c++/7/sstream:804:38: error: expected primary-expression before ‘,’ token
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
                                      ^
/usr/include/c++/7/sstream:804:50: error: expected primary-expression before ‘>’ token
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
                                                  ^
/usr/include/c++/7/sstream:804:53: error: ‘__y’ was not declared in this scope
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
                                                     ^~~
/usr/include/c++/7/sstream:804:53: note: suggested alternative: ‘__yn’
   basic_istringstream<_CharT, _Traits, _Allocator>& __y)
                                                     ^~~
                                                     __yn
/usr/include/c++/7/sstream:810:10: error: variable or field ‘swap’ declared void
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
          ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:810:10: error: ‘basic_ostringstream’ was not declared in this scope
/usr/include/c++/7/sstream:810:10: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:104:11: note:   ‘std::__cxx11::basic_ostringstream’
     class basic_ostringstream;
           ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:104:11: note:   ‘std::__cxx11::basic_ostringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:810:36: error: expected primary-expression before ‘,’ token
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
                                    ^
/usr/include/c++/7/sstream:810:45: error: expected primary-expression before ‘,’ token
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
                                             ^
/usr/include/c++/7/sstream:810:57: error: expected primary-expression before ‘>’ token
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
                                                         ^
/usr/include/c++/7/sstream:810:60: error: ‘__x’ was not declared in this scope
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
                                                            ^~~
/usr/include/c++/7/sstream:810:60: note: suggested alternative: ‘__N’
     swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
                                                            ^~~
                                                            __N
/usr/include/c++/7/sstream:811:3: error: ‘basic_ostringstream’ was not declared in this scope
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
   ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:811:3: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:104:11: note:   ‘std::__cxx11::basic_ostringstream’
     class basic_ostringstream;
           ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:104:11: note:   ‘std::__cxx11::basic_ostringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:811:29: error: expected primary-expression before ‘,’ token
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
                             ^
/usr/include/c++/7/sstream:811:38: error: expected primary-expression before ‘,’ token
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
                                      ^
/usr/include/c++/7/sstream:811:50: error: expected primary-expression before ‘>’ token
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
                                                  ^
/usr/include/c++/7/sstream:811:53: error: ‘__y’ was not declared in this scope
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
                                                     ^~~
/usr/include/c++/7/sstream:811:53: note: suggested alternative: ‘__yn’
   basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
                                                     ^~~
                                                     __yn
/usr/include/c++/7/sstream:817:10: error: variable or field ‘swap’ declared void
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
          ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:817:10: error: ‘basic_stringstream’ was not declared in this scope
/usr/include/c++/7/sstream:817:10: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:108:11: note:   ‘std::__cxx11::basic_stringstream’
     class basic_stringstream;
           ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:108:11: note:   ‘std::__cxx11::basic_stringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:817:35: error: expected primary-expression before ‘,’ token
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
                                   ^
/usr/include/c++/7/sstream:817:44: error: expected primary-expression before ‘,’ token
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
                                            ^
/usr/include/c++/7/sstream:817:56: error: expected primary-expression before ‘>’ token
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
                                                        ^
/usr/include/c++/7/sstream:817:59: error: ‘__x’ was not declared in this scope
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
                                                           ^~~
/usr/include/c++/7/sstream:817:59: note: suggested alternative: ‘__N’
     swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
                                                           ^~~
                                                           __N
/usr/include/c++/7/sstream:818:3: error: ‘basic_stringstream’ was not declared in this scope
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
   ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/sstream:818:3: note: suggested alternatives:
In file included from /usr/include/c++/7/bits/localefwd.h:41:0,
                 from /usr/include/c++/7/string:43,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/iosfwd:108:11: note:   ‘std::__cxx11::basic_stringstream’
     class basic_stringstream;
           ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/iosfwd:108:11: note:   ‘std::__cxx11::basic_stringstream’
In file included from /usr/include/c++/7/complex:45:0,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/sstream:818:28: error: expected primary-expression before ‘,’ token
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
                            ^
/usr/include/c++/7/sstream:818:37: error: expected primary-expression before ‘,’ token
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
                                     ^
/usr/include/c++/7/sstream:818:49: error: expected primary-expression before ‘>’ token
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
                                                 ^
/usr/include/c++/7/sstream:818:52: error: ‘__y’ was not declared in this scope
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
                                                    ^~~
/usr/include/c++/7/sstream:818:52: note: suggested alternative: ‘__yn’
   basic_stringstream<_CharT, _Traits, _Allocator>& __y)
                                                    ^~~
                                                    __yn
In file included from /usr/include/c++/7/sstream:826:0,
                 from /usr/include/c++/7/complex:45,
                 from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/bits/sstream.tcc:44:14: error: expected nested-name-specifier before ‘basic_stringbuf’
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
              ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:44:29: error: expected initializer before ‘<’ token
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
                             ^
/usr/include/c++/7/bits/sstream.tcc:78:14: error: expected nested-name-specifier before ‘basic_stringbuf’
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
              ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:78:29: error: expected initializer before ‘<’ token
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
                             ^
/usr/include/c++/7/bits/sstream.tcc:148:14: error: expected nested-name-specifier before ‘basic_stringbuf’
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
              ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:148:29: error: expected initializer before ‘<’ token
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
                             ^
/usr/include/c++/7/bits/sstream.tcc:166:14: error: expected nested-name-specifier before ‘basic_stringbuf’
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
              ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:166:29: error: expected initializer before ‘<’ token
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
                             ^
/usr/include/c++/7/bits/sstream.tcc:214:14: error: expected nested-name-specifier before ‘basic_stringbuf’
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
              ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:214:29: error: expected initializer before ‘<’ token
     typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
                             ^
/usr/include/c++/7/bits/sstream.tcc:245:20: error: expected initializer before ‘<’ token
     basic_stringbuf<_CharT, _Traits, _Alloc>::
                    ^
/usr/include/c++/7/bits/sstream.tcc:276:20: error: expected initializer before ‘<’ token
     basic_stringbuf<_CharT, _Traits, _Alloc>::
                    ^
/usr/include/c++/7/bits/sstream.tcc:291:25: error: ‘basic_stringbuf’ is not a class template
   extern template class basic_stringbuf<char>;
                         ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:291:25: error: explicit instantiation of non-template type ‘std::basic_stringbuf’
/usr/include/c++/7/bits/sstream.tcc:292:25: error: ‘basic_istringstream’ is not a class template
   extern template class basic_istringstream<char>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:292:25: error: explicit instantiation of non-template type ‘std::basic_istringstream’
/usr/include/c++/7/bits/sstream.tcc:293:25: error: ‘basic_ostringstream’ is not a class template
   extern template class basic_ostringstream<char>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:293:25: error: explicit instantiation of non-template type ‘std::basic_ostringstream’
/usr/include/c++/7/bits/sstream.tcc:294:25: error: ‘basic_stringstream’ is not a class template
   extern template class basic_stringstream<char>;
                         ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:294:25: error: explicit instantiation of non-template type ‘std::basic_stringstream’
/usr/include/c++/7/bits/sstream.tcc:297:25: error: ‘basic_stringbuf’ is not a class template
   extern template class basic_stringbuf<wchar_t>;
                         ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:297:25: error: conflicting declaration ‘struct std::basic_stringbuf’
/usr/include/c++/7/bits/sstream.tcc:291:25: note: previous declaration as ‘class std::basic_stringbuf’
   extern template class basic_stringbuf<char>;
                         ^~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:298:25: error: ‘basic_istringstream’ is not a class template
   extern template class basic_istringstream<wchar_t>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:298:25: error: conflicting declaration ‘struct std::basic_istringstream’
/usr/include/c++/7/bits/sstream.tcc:292:25: note: previous declaration as ‘class std::basic_istringstream’
   extern template class basic_istringstream<char>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:299:25: error: ‘basic_ostringstream’ is not a class template
   extern template class basic_ostringstream<wchar_t>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:299:25: error: conflicting declaration ‘struct std::basic_ostringstream’
/usr/include/c++/7/bits/sstream.tcc:293:25: note: previous declaration as ‘class std::basic_ostringstream’
   extern template class basic_ostringstream<char>;
                         ^~~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:300:25: error: ‘basic_stringstream’ is not a class template
   extern template class basic_stringstream<wchar_t>;
                         ^~~~~~~~~~~~~~~~~~
/usr/include/c++/7/bits/sstream.tcc:300:25: error: conflicting declaration ‘struct std::basic_stringstream’
/usr/include/c++/7/bits/sstream.tcc:294:25: note: previous declaration as ‘class std::basic_stringstream’
   extern template class basic_stringstream<char>;
                         ^~~~~~~~~~~~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:64:20: error: ‘complex’ is not a class template
   template<> class complex<float>;
                    ^~~~~~~
/usr/include/c++/7/complex:64:20: error: ‘struct std::complex’ redeclared as different kind of symbol
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:65:20: error: ‘complex’ is not a class template
   template<> class complex<double>;
                    ^~~~~~~
/usr/include/c++/7/complex:65:20: error: ‘struct std::complex’ redeclared as different kind of symbol
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:66:20: error: ‘complex’ is not a class template
   template<> class complex<long double>;
                    ^~~~~~~
/usr/include/c++/7/complex:66:20: error: ‘struct std::complex’ redeclared as different kind of symbol
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:69:40: error: ‘complex’ does not name a type
   template<typename _Tp> _Tp abs(const complex<_Tp>&);
                                        ^~~~~~~
/usr/include/c++/7/complex:69:47: error: expected ‘,’ or ‘...’ before ‘<’ token
   template<typename _Tp> _Tp abs(const complex<_Tp>&);
                                               ^
/usr/include/c++/7/complex:69:53: error: ‘_Tp ralgo::abs(int)’ conflicts with a previous declaration
   template<typename _Tp> _Tp abs(const complex<_Tp>&);
                                                     ^
In file included from /usr/include/c++/7/cstdlib:77:0,
                 from /usr/include/c++/7/stdlib.h:36,
                 from /usr/local/include/nos/io/ostream.h:5,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/bits/std_abs.h:78:3: note: previous declaration ‘namespace std { }::abs’
   abs(long double __x)
   ^~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:71:40: error: ‘complex’ does not name a type
   template<typename _Tp> _Tp arg(const complex<_Tp>&);
                                        ^~~~~~~
/usr/include/c++/7/complex:71:47: error: expected ‘,’ or ‘...’ before ‘<’ token
   template<typename _Tp> _Tp arg(const complex<_Tp>&);
                                               ^
/usr/include/c++/7/complex:73:41: error: ‘complex’ does not name a type
   template<typename _Tp> _Tp norm(const complex<_Tp>&);
                                         ^~~~~~~
/usr/include/c++/7/complex:73:48: error: expected ‘,’ or ‘...’ before ‘<’ token
   template<typename _Tp> _Tp norm(const complex<_Tp>&);
                                                ^
/usr/include/c++/7/complex:76:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:78:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);
                          ^~~~~~~
/usr/include/c++/7/complex:82:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:84:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:86:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:88:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:90:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:92:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);
                          ^~~~~~~
/usr/include/c++/7/complex:94:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);
                          ^~~~~~~
/usr/include/c++/7/complex:96:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                          ^~~~~~~
/usr/include/c++/7/complex:99:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:101:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:103:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:105:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:107:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:109:26: error: ‘complex’ does not name a type
   template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
                          ^~~~~~~
/usr/include/c++/7/complex:122:12: error: conflicting declaration of template ‘template<class _Tp> struct std::complex’
     struct complex
            ^~~~~~~
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:234:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:244:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:254:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:264:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:275:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:286:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:298:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:311:5: error: ‘complex’ does not name a type
     complex<_Tp>&
     ^~~~~~~
/usr/include/c++/7/complex:325:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:334:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:343:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:355:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:364:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:373:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:385:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:394:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:403:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:415:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:424:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:433:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:444:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:450:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:458:22: error: ‘complex’ does not name a type
     operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
                      ^~~~~~~
/usr/include/c++/7/complex:458:29: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
                             ^
/usr/include/c++/7/complex:458:64: error: ‘constexpr bool ralgo::operator==(int)’ must have an argument of class or enumerated type
     operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
                                                                ^
/usr/include/c++/7/complex:463:22: error: ‘complex’ does not name a type
     operator==(const complex<_Tp>& __x, const _Tp& __y)
                      ^~~~~~~
/usr/include/c++/7/complex:463:29: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator==(const complex<_Tp>& __x, const _Tp& __y)
                             ^
/usr/include/c++/7/complex:463:55: error: ‘constexpr bool ralgo::operator==(int)’ must have an argument of class or enumerated type
     operator==(const complex<_Tp>& __x, const _Tp& __y)
                                                       ^
/usr/include/c++/7/complex:468:38: error: ‘complex’ does not name a type
     operator==(const _Tp& __x, const complex<_Tp>& __y)
                                      ^~~~~~~
/usr/include/c++/7/complex:468:45: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator==(const _Tp& __x, const complex<_Tp>& __y)
                                             ^
/usr/include/c++/7/complex:468:55: error: ‘constexpr bool ralgo::operator==(const _Tp&, int)’ conflicts with a previous declaration
     operator==(const _Tp& __x, const complex<_Tp>& __y)
                                                       ^
In file included from /usr/include/c++/7/memory:81:0,
                 from /usr/local/include/nos/util/arglist.h:11,
                 from /usr/local/include/nos/fprint/visitor.h:5,
                 from /usr/local/include/nos/fprint/fprint.h:5,
                 from /usr/local/include/nos/fprint.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/phase.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/usr/include/c++/7/bits/shared_ptr.h:378:5: note: previous declaration ‘namespace std { }::operator==’
     operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘constexpr bool ralgo::operator==(const _Tp&, int)’:
/usr/include/c++/7/complex:469:21: error: ‘__y’ was not declared in this scope
     { return __x == __y.real() && _Tp() == __y.imag(); }
                     ^~~
/usr/include/c++/7/complex:469:21: note: suggested alternative: ‘__x’
     { return __x == __y.real() && _Tp() == __y.imag(); }
                     ^~~
                     __x
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:476:22: error: ‘complex’ does not name a type
     operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
                      ^~~~~~~
/usr/include/c++/7/complex:476:29: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
                             ^
/usr/include/c++/7/complex:476:64: error: ‘constexpr bool ralgo::operator!=(int)’ must have an argument of class or enumerated type
     operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
                                                                ^
/usr/include/c++/7/complex:481:22: error: ‘complex’ does not name a type
     operator!=(const complex<_Tp>& __x, const _Tp& __y)
                      ^~~~~~~
/usr/include/c++/7/complex:481:29: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator!=(const complex<_Tp>& __x, const _Tp& __y)
                             ^
/usr/include/c++/7/complex:481:55: error: ‘constexpr bool ralgo::operator!=(int)’ must have an argument of class or enumerated type
     operator!=(const complex<_Tp>& __x, const _Tp& __y)
                                                       ^
/usr/include/c++/7/complex:486:38: error: ‘complex’ does not name a type
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
                                      ^~~~~~~
/usr/include/c++/7/complex:486:45: error: expected ‘,’ or ‘...’ before ‘<’ token
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
                                             ^
/usr/include/c++/7/complex:486:55: error: ‘constexpr bool ralgo::operator!=(const _Tp&, int)’ conflicts with a previous declaration
     operator!=(const _Tp& __x, const complex<_Tp>& __y)
                                                       ^
In file included from /usr/include/c++/7/memory:81:0,
                 from /usr/local/include/nos/util/arglist.h:11,
                 from /usr/local/include/nos/fprint/visitor.h:5,
                 from /usr/local/include/nos/fprint/fprint.h:5,
                 from /usr/local/include/nos/fprint.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/phase.h:4,
                 from /home/mirmik/project/ralgo/./ralgo/planning/traj.h:5,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:4,
                 from ./main.cpp:3:
/usr/include/c++/7/bits/shared_ptr.h:393:5: note: previous declaration ‘namespace std { }::operator!=’
     operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
     ^~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘constexpr bool ralgo::operator!=(const _Tp&, int)’:
/usr/include/c++/7/complex:487:21: error: ‘__y’ was not declared in this scope
     { return __x != __y.real() || _Tp() != __y.imag(); }
                     ^~~
/usr/include/c++/7/complex:487:21: note: suggested alternative: ‘__x’
     { return __x != __y.real() || _Tp() != __y.imag(); }
                     ^~~
                     __x
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:492:5: error: ‘basic_istream’ does not name a type
     basic_istream<_CharT, _Traits>&
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex:527:5: error: ‘basic_ostream’ does not name a type
     basic_ostream<_CharT, _Traits>&
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex:542:16: error: ‘complex’ does not name a type
     real(const complex<_Tp>& __z)
                ^~~~~~~
/usr/include/c++/7/complex:542:23: error: expected ‘,’ or ‘...’ before ‘<’ token
     real(const complex<_Tp>& __z)
                       ^
/usr/include/c++/7/complex: In function ‘constexpr _Tp ralgo::real(int)’:
/usr/include/c++/7/complex:543:14: error: ‘__z’ was not declared in this scope
     { return __z.real(); }
              ^~~
/usr/include/c++/7/complex:543:14: note: suggested alternative: ‘__N’
     { return __z.real(); }
              ^~~
              __N
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:547:16: error: ‘complex’ does not name a type
     imag(const complex<_Tp>& __z)
                ^~~~~~~
/usr/include/c++/7/complex:547:23: error: expected ‘,’ or ‘...’ before ‘<’ token
     imag(const complex<_Tp>& __z)
                       ^
/usr/include/c++/7/complex: In function ‘constexpr _Tp ralgo::imag(int)’:
/usr/include/c++/7/complex:548:14: error: ‘__z’ was not declared in this scope
     { return __z.imag(); }
              ^~~
/usr/include/c++/7/complex:548:14: note: suggested alternative: ‘__N’
     { return __z.imag(); }
              ^~~
              __N
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:574:25: error: ‘complex’ does not name a type
     __complex_abs(const complex<_Tp>& __z)
                         ^~~~~~~
/usr/include/c++/7/complex:574:32: error: expected ‘,’ or ‘...’ before ‘<’ token
     __complex_abs(const complex<_Tp>& __z)
                                ^
/usr/include/c++/7/complex: In function ‘_Tp ralgo::__complex_abs(int)’:
/usr/include/c++/7/complex:576:17: error: ‘__z’ was not declared in this scope
       _Tp __x = __z.real();
                 ^~~
/usr/include/c++/7/complex:576:17: note: suggested alternative: ‘__x’
       _Tp __x = __z.real();
                 ^~~
                 __x
/usr/include/c++/7/complex: In function ‘float ralgo::__complex_abs(__complex__ float)’:
/usr/include/c++/7/complex:588:38: error: ‘float ralgo::__complex_abs(__complex__ float)’ conflicts with a previous declaration
   __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }
                                      ^
/usr/include/c++/7/complex:574:5: note: previous declaration ‘_Tp ralgo::__complex_abs(int)’
     __complex_abs(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘double ralgo::__complex_abs(__complex__ double)’:
/usr/include/c++/7/complex:591:39: error: ‘double ralgo::__complex_abs(__complex__ double)’ conflicts with a previous declaration
   __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }
                                       ^
/usr/include/c++/7/complex:574:5: note: previous declaration ‘_Tp ralgo::__complex_abs(int)’
     __complex_abs(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘long double ralgo::__complex_abs(const __complex__ long double&)’:
/usr/include/c++/7/complex:594:51: error: ‘long double ralgo::__complex_abs(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_abs(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:574:5: note: previous declaration ‘_Tp ralgo::__complex_abs(int)’
     __complex_abs(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:599:15: error: ‘complex’ does not name a type
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
               ^~~~~~~
/usr/include/c++/7/complex:599:22: error: expected ‘,’ or ‘...’ before ‘<’ token
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
                      ^
/usr/include/c++/7/complex:599:32: error: ‘_Tp ralgo::abs(int)’ conflicts with a previous declaration
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
                                ^
In file included from /usr/include/c++/7/cstdlib:77:0,
                 from /usr/include/c++/7/stdlib.h:36,
                 from /usr/local/include/nos/io/ostream.h:5,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/bits/std_abs.h:78:3: note: previous declaration ‘namespace std { }::abs’
   abs(long double __x)
   ^~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘_Tp ralgo::abs(int)’:
/usr/include/c++/7/complex:599:57: error: ‘__z’ was not declared in this scope
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
                                                         ^~~
/usr/include/c++/7/complex:599:57: note: suggested alternative: ‘__N’
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
                                                         ^~~
                                                         __N
/usr/include/c++/7/complex:599:43: error: there are no arguments to ‘__complex_abs’ that depend on a template parameter, so a declaration of ‘__complex_abs’ must be available [-fpermissive]
     abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
                                           ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:610:25: error: ‘complex’ does not name a type
     __complex_arg(const complex<_Tp>& __z)
                         ^~~~~~~
/usr/include/c++/7/complex:610:32: error: expected ‘,’ or ‘...’ before ‘<’ token
     __complex_arg(const complex<_Tp>& __z)
                                ^
/usr/include/c++/7/complex: In function ‘_Tp ralgo::__complex_arg(int)’:
/usr/include/c++/7/complex:611:21: error: ‘__z’ was not declared in this scope
     { return  atan2(__z.imag(), __z.real()); }
                     ^~~
/usr/include/c++/7/complex:611:21: note: suggested alternative: ‘__N’
     { return  atan2(__z.imag(), __z.real()); }
                     ^~~
                     __N
/usr/include/c++/7/complex: In function ‘float ralgo::__complex_arg(__complex__ float)’:
/usr/include/c++/7/complex:615:38: error: ‘float ralgo::__complex_arg(__complex__ float)’ conflicts with a previous declaration
   __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }
                                      ^
/usr/include/c++/7/complex:610:5: note: previous declaration ‘_Tp ralgo::__complex_arg(int)’
     __complex_arg(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘double ralgo::__complex_arg(__complex__ double)’:
/usr/include/c++/7/complex:618:39: error: ‘double ralgo::__complex_arg(__complex__ double)’ conflicts with a previous declaration
   __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }
                                       ^
/usr/include/c++/7/complex:610:5: note: previous declaration ‘_Tp ralgo::__complex_arg(int)’
     __complex_arg(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘long double ralgo::__complex_arg(const __complex__ long double&)’:
/usr/include/c++/7/complex:621:51: error: ‘long double ralgo::__complex_arg(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_arg(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:610:5: note: previous declaration ‘_Tp ralgo::__complex_arg(int)’
     __complex_arg(const complex<_Tp>& __z)
     ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:626:15: error: ‘complex’ does not name a type
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
               ^~~~~~~
/usr/include/c++/7/complex:626:22: error: expected ‘,’ or ‘...’ before ‘<’ token
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
                      ^
/usr/include/c++/7/complex:626:32: error: ‘_Tp ralgo::arg(int)’ conflicts with a previous declaration
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
                                ^
/usr/include/c++/7/complex:71:30: note: previous declaration ‘_Tp ralgo::arg(int)’
   template<typename _Tp> _Tp arg(const complex<_Tp>&);
                              ^~~
/usr/include/c++/7/complex: In function ‘_Tp ralgo::arg(int)’:
/usr/include/c++/7/complex:626:57: error: ‘__z’ was not declared in this scope
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
                                                         ^~~
/usr/include/c++/7/complex:626:57: note: suggested alternative: ‘__N’
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
                                                         ^~~
                                                         __N
/usr/include/c++/7/complex:626:43: error: there are no arguments to ‘__complex_arg’ that depend on a template parameter, so a declaration of ‘__complex_arg’ must be available [-fpermissive]
     arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
                                           ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:642:42: error: ‘complex’ does not name a type
         static inline _Tp _S_do_it(const complex<_Tp>& __z)
                                          ^~~~~~~
/usr/include/c++/7/complex:642:49: error: expected ‘,’ or ‘...’ before ‘<’ token
         static inline _Tp _S_do_it(const complex<_Tp>& __z)
                                                 ^
/usr/include/c++/7/complex: In static member function ‘static _Tp std::_Norm_helper<<anonymous> >::_S_do_it(int)’:
/usr/include/c++/7/complex:644:27: error: ‘__z’ was not declared in this scope
           const _Tp __x = __z.real();
                           ^~~
/usr/include/c++/7/complex:644:27: note: suggested alternative: ‘__x’
           const _Tp __x = __z.real();
                           ^~~
                           __x
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:651:12: error: ‘_Norm_helper’ is not a class template
     struct _Norm_helper<true>
            ^~~~~~~~~~~~
/usr/include/c++/7/complex:651:29: error: ‘struct std::_Norm_helper’ redeclared as different kind of symbol
     struct _Norm_helper<true>
                             ^
/usr/include/c++/7/complex:639:12: note: previous declaration ‘template<bool <anonymous> > struct std::_Norm_helper’
     struct _Norm_helper
            ^~~~~~~~~~~~
/usr/include/c++/7/complex:663:16: error: ‘complex’ does not name a type
     norm(const complex<_Tp>& __z)
                ^~~~~~~
/usr/include/c++/7/complex:663:23: error: expected ‘,’ or ‘...’ before ‘<’ token
     norm(const complex<_Tp>& __z)
                       ^
/usr/include/c++/7/complex:663:33: error: ‘_Tp ralgo::norm(int)’ conflicts with a previous declaration
     norm(const complex<_Tp>& __z)
                                 ^
/usr/include/c++/7/complex:73:30: note: previous declaration ‘_Tp ralgo::norm(int)’
   template<typename _Tp> _Tp norm(const complex<_Tp>&);
                              ^~~~
/usr/include/c++/7/complex: In function ‘_Tp ralgo::norm(int)’:
/usr/include/c++/7/complex:665:14: error: ‘_Norm_helper’ was not declared in this scope
       return _Norm_helper<__is_floating<_Tp>::__value
              ^~~~~~~~~~~~
/usr/include/c++/7/complex:665:14: note: suggested alternative:
/usr/include/c++/7/complex:639:12: note:   ‘std::_Norm_helper’
     struct _Norm_helper
            ^~~~~~~~~~~~
/usr/include/c++/7/complex:665:27: error: ‘__is_floating’ was not declared in this scope
       return _Norm_helper<__is_floating<_Tp>::__value
                           ^~~~~~~~~~~~~
/usr/include/c++/7/complex:665:27: note: suggested alternative:
In file included from /usr/include/c++/7/bits/stl_algobase.h:61:0,
                 from /usr/include/c++/7/bits/char_traits.h:39,
                 from /usr/include/c++/7/string:40,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/bits/cpp_type_traits.h:279:12: note:   ‘std::__is_floating’
     struct __is_floating
            ^~~~~~~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:665:44: error: expected primary-expression before ‘>’ token
       return _Norm_helper<__is_floating<_Tp>::__value
                                            ^
/usr/include/c++/7/complex:665:47: error: ‘::__value’ has not been declared
       return _Norm_helper<__is_floating<_Tp>::__value
                                               ^~~~~~~
/usr/include/c++/7/complex:665:47: note: suggested alternative: ‘__volget’
       return _Norm_helper<__is_floating<_Tp>::__value
                                               ^~~~~~~
                                               __volget
/usr/include/c++/7/complex:666:27: error: ‘::_S_do_it’ has not been declared
  && !_GLIBCXX_FAST_MATH>::_S_do_it(__z);
                           ^~~~~~~~
/usr/include/c++/7/complex:666:27: note: suggested alternative: ‘_S_eofbit’
  && !_GLIBCXX_FAST_MATH>::_S_do_it(__z);
                           ^~~~~~~~
                           _S_eofbit
/usr/include/c++/7/complex:666:36: error: ‘__z’ was not declared in this scope
  && !_GLIBCXX_FAST_MATH>::_S_do_it(__z);
                                    ^~~
/usr/include/c++/7/complex:666:36: note: suggested alternative: ‘__N’
  && !_GLIBCXX_FAST_MATH>::_S_do_it(__z);
                                    ^~~
                                    __N
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:670:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:678:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:686:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_cos(__complex__ double)’:
/usr/include/c++/7/complex:699:39: error: ‘__complex__ double ralgo::__complex_cos(__complex__ double)’ conflicts with a previous declaration
   __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }
                                       ^
/usr/include/c++/7/complex:696:3: note: previous declaration ‘__complex__ float ralgo::__complex_cos(__complex__ float)’
   __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_cos(const __complex__ long double&)’:
/usr/include/c++/7/complex:702:51: error: ‘__complex__ long double ralgo::__complex_cos(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_cos(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:696:3: note: previous declaration ‘__complex__ float ralgo::__complex_cos(__complex__ float)’
   __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:706:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:716:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_cosh(__complex__ double)’:
/usr/include/c++/7/complex:729:40: error: ‘__complex__ double ralgo::__complex_cosh(__complex__ double)’ conflicts with a previous declaration
   __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }
                                        ^
/usr/include/c++/7/complex:726:3: note: previous declaration ‘__complex__ float ralgo::__complex_cosh(__complex__ float)’
   __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_cosh(const __complex__ long double&)’:
/usr/include/c++/7/complex:732:52: error: ‘__complex__ long double ralgo::__complex_cosh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_cosh(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:726:3: note: previous declaration ‘__complex__ float ralgo::__complex_cosh(__complex__ float)’
   __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:736:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:746:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_exp(__complex__ double)’:
/usr/include/c++/7/complex:755:39: error: ‘__complex__ double ralgo::__complex_exp(__complex__ double)’ conflicts with a previous declaration
   __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }
                                       ^
/usr/include/c++/7/complex:752:3: note: previous declaration ‘__complex__ float ralgo::__complex_exp(__complex__ float)’
   __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_exp(const __complex__ long double&)’:
/usr/include/c++/7/complex:758:51: error: ‘__complex__ long double ralgo::__complex_exp(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_exp(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:752:3: note: previous declaration ‘__complex__ float ralgo::__complex_exp(__complex__ float)’
   __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:762:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:773:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_log(__complex__ double)’:
/usr/include/c++/7/complex:782:39: error: ‘__complex__ double ralgo::__complex_log(__complex__ double)’ conflicts with a previous declaration
   __complex_log(__complex__ double __z) { return __builtin_clog(__z); }
                                       ^
/usr/include/c++/7/complex:779:3: note: previous declaration ‘__complex__ float ralgo::__complex_log(__complex__ float)’
   __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_log(const __complex__ long double&)’:
/usr/include/c++/7/complex:785:51: error: ‘__complex__ long double ralgo::__complex_log(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_log(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:779:3: note: previous declaration ‘__complex__ float ralgo::__complex_log(__complex__ float)’
   __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:789:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:798:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:804:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_sin(__complex__ double)’:
/usr/include/c++/7/complex:817:39: error: ‘__complex__ double ralgo::__complex_sin(__complex__ double)’ conflicts with a previous declaration
   __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }
                                       ^
/usr/include/c++/7/complex:814:3: note: previous declaration ‘__complex__ float ralgo::__complex_sin(__complex__ float)’
   __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_sin(const __complex__ long double&)’:
/usr/include/c++/7/complex:820:51: error: ‘__complex__ long double ralgo::__complex_sin(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_sin(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:814:3: note: previous declaration ‘__complex__ float ralgo::__complex_sin(__complex__ float)’
   __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:824:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:834:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_sinh(__complex__ double)’:
/usr/include/c++/7/complex:847:40: error: ‘__complex__ double ralgo::__complex_sinh(__complex__ double)’ conflicts with a previous declaration
   __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }
                                        ^
/usr/include/c++/7/complex:844:3: note: previous declaration ‘__complex__ float ralgo::__complex_sinh(__complex__ float)’
   __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_sinh(const __complex__ long double&)’:
/usr/include/c++/7/complex:850:52: error: ‘__complex__ long double ralgo::__complex_sinh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_sinh(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:844:3: note: previous declaration ‘__complex__ float ralgo::__complex_sinh(__complex__ float)’
   __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:854:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:865:5: error: ‘complex’ does not name a type
     complex<_Tp>
     ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_sqrt(__complex__ double)’:
/usr/include/c++/7/complex:891:40: error: ‘__complex__ double ralgo::__complex_sqrt(__complex__ double)’ conflicts with a previous declaration
   __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }
                                        ^
/usr/include/c++/7/complex:888:3: note: previous declaration ‘__complex__ float ralgo::__complex_sqrt(__complex__ float)’
   __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_sqrt(const __complex__ long double&)’:
/usr/include/c++/7/complex:894:52: error: ‘__complex__ long double ralgo::__complex_sqrt(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_sqrt(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:888:3: note: previous declaration ‘__complex__ float ralgo::__complex_sqrt(__complex__ float)’
   __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:898:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:909:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_tan(__complex__ double)’:
/usr/include/c++/7/complex:918:39: error: ‘__complex__ double ralgo::__complex_tan(__complex__ double)’ conflicts with a previous declaration
   __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }
                                       ^
/usr/include/c++/7/complex:915:3: note: previous declaration ‘__complex__ float ralgo::__complex_tan(__complex__ float)’
   __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_tan(const __complex__ long double&)’:
/usr/include/c++/7/complex:921:51: error: ‘__complex__ long double ralgo::__complex_tan(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_tan(const __complex__ long double& __z)
                                                   ^
/usr/include/c++/7/complex:915:3: note: previous declaration ‘__complex__ float ralgo::__complex_tan(__complex__ float)’
   __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:925:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:937:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_tanh(__complex__ double)’:
/usr/include/c++/7/complex:946:40: error: ‘__complex__ double ralgo::__complex_tanh(__complex__ double)’ conflicts with a previous declaration
   __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }
                                        ^
/usr/include/c++/7/complex:943:3: note: previous declaration ‘__complex__ float ralgo::__complex_tanh(__complex__ float)’
   __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_tanh(const __complex__ long double&)’:
/usr/include/c++/7/complex:949:52: error: ‘__complex__ long double ralgo::__complex_tanh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_tanh(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:943:3: note: previous declaration ‘__complex__ float ralgo::__complex_tanh(__complex__ float)’
   __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }
   ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:953:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:966:5: error: ‘complex’ does not name a type
     complex<_Tp>
     ^~~~~~~
/usr/include/c++/7/complex:988:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:997:5: error: ‘complex’ does not name a type
     complex<_Tp>
     ^~~~~~~
/usr/include/c++/7/complex:1012:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_pow(__complex__ double, __complex__ double)’:
/usr/include/c++/7/complex:1022:63: error: ‘__complex__ double ralgo::__complex_pow(__complex__ double, __complex__ double)’ conflicts with a previous declaration
   __complex_pow(__complex__ double __x, __complex__ double __y)
                                                               ^
/usr/include/c++/7/complex:1018:3: note: previous declaration ‘__complex__ float ralgo::__complex_pow(__complex__ float, __complex__ float)’
   __complex_pow(__complex__ float __x, __complex__ float __y)
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_pow(const __complex__ long double&, const __complex__ long double&)’:
/usr/include/c++/7/complex:1027:37: error: ‘__complex__ long double ralgo::__complex_pow(const __complex__ long double&, const __complex__ long double&)’ conflicts with a previous declaration
   const __complex__ long double& __y)
                                     ^
/usr/include/c++/7/complex:1018:3: note: previous declaration ‘__complex__ float ralgo::__complex_pow(__complex__ float, __complex__ float)’
   __complex_pow(__complex__ float __x, __complex__ float __y)
   ^~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1031:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:1042:12: error: ‘complex’ does not name a type
     inline complex<_Tp>
            ^~~~~~~
/usr/include/c++/7/complex:1053:12: error: ‘complex’ is not a class template
     struct complex<float>
            ^~~~~~~
/usr/include/c++/7/complex:1053:25: error: ‘struct std::complex’ redeclared as different kind of symbol
     struct complex<float>
                         ^
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:1202:12: error: ‘complex’ is not a class template
     struct complex<double>
            ^~~~~~~
/usr/include/c++/7/complex:1202:26: error: ‘struct std::complex’ redeclared as different kind of symbol
     struct complex<double>
                          ^
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:1352:12: error: ‘complex’ is not a class template
     struct complex<long double>
            ^~~~~~~
/usr/include/c++/7/complex:1352:31: error: ‘struct std::complex’ redeclared as different kind of symbol
     struct complex<long double>
                               ^
/usr/include/c++/7/complex:63:32: note: previous declaration ‘template<class _Tp> class std::complex’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex:1504:3: error: ‘complex’ does not name a type
   complex<float>::complex(const complex<double>& __z)
   ^~~~~~~
/usr/include/c++/7/complex:1508:3: error: ‘complex’ does not name a type
   complex<float>::complex(const complex<long double>& __z)
   ^~~~~~~
/usr/include/c++/7/complex:1512:3: error: ‘complex’ does not name a type
   complex<double>::complex(const complex<long double>& __z)
   ^~~~~~~
/usr/include/c++/7/complex:1519:19: error: ‘istream’ is not a template function
   extern template istream& operator>>(istream&, complex<float>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1519:26: error: expected ‘;’ before ‘&’ token
   extern template istream& operator>>(istream&, complex<float>&);
                          ^
/usr/include/c++/7/complex:1520:19: error: ‘ostream’ is not a template function
   extern template ostream& operator<<(ostream&, const complex<float>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1520:26: error: expected ‘;’ before ‘&’ token
   extern template ostream& operator<<(ostream&, const complex<float>&);
                          ^
/usr/include/c++/7/complex:1521:19: error: ‘istream’ is not a template function
   extern template istream& operator>>(istream&, complex<double>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1521:26: error: expected ‘;’ before ‘&’ token
   extern template istream& operator>>(istream&, complex<double>&);
                          ^
/usr/include/c++/7/complex:1522:19: error: ‘ostream’ is not a template function
   extern template ostream& operator<<(ostream&, const complex<double>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1522:26: error: expected ‘;’ before ‘&’ token
   extern template ostream& operator<<(ostream&, const complex<double>&);
                          ^
/usr/include/c++/7/complex:1523:19: error: ‘istream’ is not a template function
   extern template istream& operator>>(istream&, complex<long double>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1523:26: error: expected ‘;’ before ‘&’ token
   extern template istream& operator>>(istream&, complex<long double>&);
                          ^
/usr/include/c++/7/complex:1524:19: error: ‘ostream’ is not a template function
   extern template ostream& operator<<(ostream&, const complex<long double>&);
                   ^~~~~~~
/usr/include/c++/7/complex:1524:26: error: expected ‘;’ before ‘&’ token
   extern template ostream& operator<<(ostream&, const complex<long double>&);
                          ^
/usr/include/c++/7/complex:1527:19: error: ‘wistream’ is not a template function
   extern template wistream& operator>>(wistream&, complex<float>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1527:27: error: expected ‘;’ before ‘&’ token
   extern template wistream& operator>>(wistream&, complex<float>&);
                           ^
/usr/include/c++/7/complex:1528:19: error: ‘wostream’ is not a template function
   extern template wostream& operator<<(wostream&, const complex<float>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1528:27: error: expected ‘;’ before ‘&’ token
   extern template wostream& operator<<(wostream&, const complex<float>&);
                           ^
/usr/include/c++/7/complex:1529:19: error: ‘wistream’ is not a template function
   extern template wistream& operator>>(wistream&, complex<double>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1529:27: error: expected ‘;’ before ‘&’ token
   extern template wistream& operator>>(wistream&, complex<double>&);
                           ^
/usr/include/c++/7/complex:1530:19: error: ‘wostream’ is not a template function
   extern template wostream& operator<<(wostream&, const complex<double>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1530:27: error: expected ‘;’ before ‘&’ token
   extern template wostream& operator<<(wostream&, const complex<double>&);
                           ^
/usr/include/c++/7/complex:1531:19: error: ‘wistream’ is not a template function
   extern template wistream& operator>>(wistream&, complex<long double>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1531:27: error: expected ‘;’ before ‘&’ token
   extern template wistream& operator>>(wistream&, complex<long double>&);
                           ^
/usr/include/c++/7/complex:1532:19: error: ‘wostream’ is not a template function
   extern template wostream& operator<<(wostream&, const complex<long double>&);
                   ^~~~~~~~
/usr/include/c++/7/complex:1532:27: error: expected ‘;’ before ‘&’ token
   extern template wostream& operator<<(wostream&, const complex<long double>&);
                           ^
/usr/include/c++/7/complex:1547:12: error: ‘__promote_2’ is not a class template
     struct __promote_2<std::complex<_Tp>, _Up>
            ^~~~~~~~~~~
/usr/include/c++/7/complex:1547:46: error: conflicting declaration of template ‘template<class _Tp, class _Up> struct __gnu_cxx::__promote_2’
     struct __promote_2<std::complex<_Tp>, _Up>
                                              ^
In file included from /usr/include/c++/7/bits/stl_algobase.h:62:0,
                 from /usr/include/c++/7/bits/char_traits.h:39,
                 from /usr/include/c++/7/string:40,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/ext/type_traits.h:193:12: note: previous declaration ‘template<class _Tp, class _Up, class _Tp2, class _Up2> struct __gnu_cxx::__promote_2’
     struct __promote_2
            ^~~~~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1554:12: error: ‘__promote_2’ is not a class template
     struct __promote_2<_Tp, std::complex<_Up> >
            ^~~~~~~~~~~
/usr/include/c++/7/complex:1554:47: error: conflicting declaration of template ‘template<class _Tp, class _Up> struct __gnu_cxx::__promote_2’
     struct __promote_2<_Tp, std::complex<_Up> >
                                               ^
In file included from /usr/include/c++/7/bits/stl_algobase.h:62:0,
                 from /usr/include/c++/7/bits/char_traits.h:39,
                 from /usr/include/c++/7/string:40,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/ext/type_traits.h:193:12: note: previous declaration ‘template<class _Tp, class _Up, class _Tp2, class _Up2> struct __gnu_cxx::__promote_2’
     struct __promote_2
            ^~~~~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1561:12: error: ‘__promote_2’ is not a class template
     struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
            ^~~~~~~~~~~
/usr/include/c++/7/complex:1561:61: error: conflicting declaration of template ‘template<class _Tp, class _Up> struct __gnu_cxx::__promote_2’
     struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
                                                             ^
In file included from /usr/include/c++/7/bits/stl_algobase.h:62:0,
                 from /usr/include/c++/7/bits/char_traits.h:39,
                 from /usr/include/c++/7/string:40,
                 from /usr/local/include/igris/util/hexascii.h:6,
                 from /usr/local/include/nos/io/ostream.h:8,
                 from /usr/local/include/nos/print.h:4,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:4,
                 from ./main.cpp:2:
/usr/include/c++/7/ext/type_traits.h:193:12: note: previous declaration ‘template<class _Tp, class _Up, class _Tp2, class _Up2> struct __gnu_cxx::__promote_2’
     struct __promote_2
            ^~~~~~~~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1577:73: error: ‘std::complex<_Tp> ralgo::acos(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
                                                                         ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:99:5: note: previous declaration ‘namespace std { }::acos’
     acos(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1578:73: error: ‘std::complex<_Tp> ralgo::asin(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
                                                                         ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:118:5: note: previous declaration ‘namespace std { }::asin’
     asin(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1579:73: error: ‘std::complex<_Tp> ralgo::atan(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);
                                                                         ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:137:5: note: previous declaration ‘namespace std { }::atan’
     atan(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1581:74: error: ‘std::complex<_Tp> ralgo::acosh(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
                                                                          ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1241:5: note: previous declaration ‘namespace std { }::acosh’
     acosh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1582:74: error: ‘std::complex<_Tp> ralgo::asinh(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
                                                                          ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1259:5: note: previous declaration ‘namespace std { }::asinh’
     asinh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1583:74: error: ‘std::complex<_Tp> ralgo::atanh(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);
                                                                          ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1277:5: note: previous declaration ‘namespace std { }::atanh’
     atanh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1585:73: error: ‘_Tp ralgo::fabs(const std::complex<_Tp>&)’ conflicts with a previous declaration
   template<typename _Tp> _Tp               fabs(const std::complex<_Tp>&);
                                                                         ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:253:5: note: previous declaration ‘namespace std { }::fabs’
     fabs(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_acos(__complex__ float)’:
/usr/include/c++/7/complex:1598:39: error: ‘__complex__ float ralgo::__complex_acos(__complex__ float)’ conflicts with a previous declaration
   __complex_acos(__complex__ float __z)
                                       ^
/usr/include/c++/7/complex:1589:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acos(const std::complex<_Tp>&)’
     __complex_acos(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_acos(__complex__ double)’:
/usr/include/c++/7/complex:1602:40: error: ‘__complex__ double ralgo::__complex_acos(__complex__ double)’ conflicts with a previous declaration
   __complex_acos(__complex__ double __z)
                                        ^
/usr/include/c++/7/complex:1589:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acos(const std::complex<_Tp>&)’
     __complex_acos(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_acos(const __complex__ long double&)’:
/usr/include/c++/7/complex:1606:52: error: ‘__complex__ long double ralgo::__complex_acos(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_acos(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:1589:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acos(const std::complex<_Tp>&)’
     __complex_acos(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1611:38: error: ‘std::complex<_Tp> ralgo::acos(const std::complex<_Tp>&)’ conflicts with a previous declaration
     acos(const std::complex<_Tp>& __z)
                                      ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:99:5: note: previous declaration ‘namespace std { }::acos’
     acos(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_asin(__complex__ float)’:
/usr/include/c++/7/complex:1634:39: error: ‘__complex__ float ralgo::__complex_asin(__complex__ float)’ conflicts with a previous declaration
   __complex_asin(__complex__ float __z)
                                       ^
/usr/include/c++/7/complex:1625:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asin(const std::complex<_Tp>&)’
     __complex_asin(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_asin(__complex__ double)’:
/usr/include/c++/7/complex:1638:40: error: ‘__complex__ double ralgo::__complex_asin(__complex__ double)’ conflicts with a previous declaration
   __complex_asin(__complex__ double __z)
                                        ^
/usr/include/c++/7/complex:1625:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asin(const std::complex<_Tp>&)’
     __complex_asin(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_asin(const __complex__ long double&)’:
/usr/include/c++/7/complex:1642:52: error: ‘__complex__ long double ralgo::__complex_asin(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_asin(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:1625:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asin(const std::complex<_Tp>&)’
     __complex_asin(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1647:38: error: ‘std::complex<_Tp> ralgo::asin(const std::complex<_Tp>&)’ conflicts with a previous declaration
     asin(const std::complex<_Tp>& __z)
                                      ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:118:5: note: previous declaration ‘namespace std { }::asin’
     asin(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_atan(__complex__ float)’:
/usr/include/c++/7/complex:1678:39: error: ‘__complex__ float ralgo::__complex_atan(__complex__ float)’ conflicts with a previous declaration
   __complex_atan(__complex__ float __z)
                                       ^
/usr/include/c++/7/complex:1661:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atan(const std::complex<_Tp>&)’
     __complex_atan(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_atan(__complex__ double)’:
/usr/include/c++/7/complex:1682:40: error: ‘__complex__ double ralgo::__complex_atan(__complex__ double)’ conflicts with a previous declaration
   __complex_atan(__complex__ double __z)
                                        ^
/usr/include/c++/7/complex:1661:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atan(const std::complex<_Tp>&)’
     __complex_atan(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_atan(const __complex__ long double&)’:
/usr/include/c++/7/complex:1686:52: error: ‘__complex__ long double ralgo::__complex_atan(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_atan(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:1661:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atan(const std::complex<_Tp>&)’
     __complex_atan(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1691:38: error: ‘std::complex<_Tp> ralgo::atan(const std::complex<_Tp>&)’ conflicts with a previous declaration
     atan(const std::complex<_Tp>& __z)
                                      ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:137:5: note: previous declaration ‘namespace std { }::atan’
     atan(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_acosh(__complex__ float)’:
/usr/include/c++/7/complex:1714:40: error: ‘__complex__ float ralgo::__complex_acosh(__complex__ float)’ conflicts with a previous declaration
   __complex_acosh(__complex__ float __z)
                                        ^
/usr/include/c++/7/complex:1705:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acosh(const std::complex<_Tp>&)’
     __complex_acosh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_acosh(__complex__ double)’:
/usr/include/c++/7/complex:1718:41: error: ‘__complex__ double ralgo::__complex_acosh(__complex__ double)’ conflicts with a previous declaration
   __complex_acosh(__complex__ double __z)
                                         ^
/usr/include/c++/7/complex:1705:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acosh(const std::complex<_Tp>&)’
     __complex_acosh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_acosh(const __complex__ long double&)’:
/usr/include/c++/7/complex:1722:53: error: ‘__complex__ long double ralgo::__complex_acosh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_acosh(const __complex__ long double& __z)
                                                     ^
/usr/include/c++/7/complex:1705:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_acosh(const std::complex<_Tp>&)’
     __complex_acosh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1727:39: error: ‘std::complex<_Tp> ralgo::acosh(const std::complex<_Tp>&)’ conflicts with a previous declaration
     acosh(const std::complex<_Tp>& __z)
                                       ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1241:5: note: previous declaration ‘namespace std { }::acosh’
     acosh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_asinh(__complex__ float)’:
/usr/include/c++/7/complex:1753:40: error: ‘__complex__ float ralgo::__complex_asinh(__complex__ float)’ conflicts with a previous declaration
   __complex_asinh(__complex__ float __z)
                                        ^
/usr/include/c++/7/complex:1741:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asinh(const std::complex<_Tp>&)’
     __complex_asinh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_asinh(__complex__ double)’:
/usr/include/c++/7/complex:1757:41: error: ‘__complex__ double ralgo::__complex_asinh(__complex__ double)’ conflicts with a previous declaration
   __complex_asinh(__complex__ double __z)
                                         ^
/usr/include/c++/7/complex:1741:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asinh(const std::complex<_Tp>&)’
     __complex_asinh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_asinh(const __complex__ long double&)’:
/usr/include/c++/7/complex:1761:53: error: ‘__complex__ long double ralgo::__complex_asinh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_asinh(const __complex__ long double& __z)
                                                     ^
/usr/include/c++/7/complex:1741:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_asinh(const std::complex<_Tp>&)’
     __complex_asinh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1766:39: error: ‘std::complex<_Tp> ralgo::asinh(const std::complex<_Tp>&)’ conflicts with a previous declaration
     asinh(const std::complex<_Tp>& __z)
                                       ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1259:5: note: previous declaration ‘namespace std { }::asinh’
     asinh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_atanh(__complex__ float)’:
/usr/include/c++/7/complex:1797:40: error: ‘__complex__ float ralgo::__complex_atanh(__complex__ float)’ conflicts with a previous declaration
   __complex_atanh(__complex__ float __z)
                                        ^
/usr/include/c++/7/complex:1780:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atanh(const std::complex<_Tp>&)’
     __complex_atanh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_atanh(__complex__ double)’:
/usr/include/c++/7/complex:1801:41: error: ‘__complex__ double ralgo::__complex_atanh(__complex__ double)’ conflicts with a previous declaration
   __complex_atanh(__complex__ double __z)
                                         ^
/usr/include/c++/7/complex:1780:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atanh(const std::complex<_Tp>&)’
     __complex_atanh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_atanh(const __complex__ long double&)’:
/usr/include/c++/7/complex:1805:53: error: ‘__complex__ long double ralgo::__complex_atanh(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_atanh(const __complex__ long double& __z)
                                                     ^
/usr/include/c++/7/complex:1780:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_atanh(const std::complex<_Tp>&)’
     __complex_atanh(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1810:39: error: ‘std::complex<_Tp> ralgo::atanh(const std::complex<_Tp>&)’ conflicts with a previous declaration
     atanh(const std::complex<_Tp>& __z)
                                       ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:1277:5: note: previous declaration ‘namespace std { }::atanh’
     atanh(_Tp __x)
     ^~~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1827:38: error: ‘_Tp ralgo::fabs(const std::complex<_Tp>&)’ conflicts with a previous declaration
     fabs(const std::complex<_Tp>& __z)
                                      ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:253:5: note: previous declaration ‘namespace std { }::fabs’
     fabs(_Tp __x)
     ^~~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1833:16: error: ‘typename __gnu_cxx::__promote<_Tp>::__type ralgo::arg(_Tp)’ conflicts with a previous declaration
     arg(_Tp __x)
                ^
/usr/include/c++/7/complex:71:30: note: previous declaration ‘_Tp ralgo::arg(int)’
   template<typename _Tp> _Tp arg(const complex<_Tp>&);
                              ^~~
/usr/include/c++/7/complex:1846:13: error: ‘constexpr typename __gnu_cxx::__promote<_Tp>::__type ralgo::imag(_Tp)’ conflicts with a previous declaration
     imag(_Tp)
             ^
/usr/include/c++/7/complex:547:5: note: previous declaration ‘constexpr _Tp ralgo::imag(int)’
     imag(const complex<_Tp>& __z)
     ^~~~
/usr/include/c++/7/complex:1851:17: error: ‘typename __gnu_cxx::__promote<_Tp>::__type ralgo::norm(_Tp)’ conflicts with a previous declaration
     norm(_Tp __x)
                 ^
/usr/include/c++/7/complex:73:30: note: previous declaration ‘_Tp ralgo::norm(int)’
   template<typename _Tp> _Tp norm(const complex<_Tp>&);
                              ^~~~
/usr/include/c++/7/complex:1859:17: error: ‘constexpr typename __gnu_cxx::__promote<_Tp>::__type ralgo::real(_Tp)’ conflicts with a previous declaration
     real(_Tp __x)
                 ^
/usr/include/c++/7/complex:542:5: note: previous declaration ‘constexpr _Tp ralgo::real(int)’
     real(const complex<_Tp>& __z)
     ^~~~
/usr/include/c++/7/complex:1864:53: error: ‘std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type> ralgo::pow(const std::complex<_Tp>&, const _Up&)’ conflicts with a previous declaration
     pow(const std::complex<_Tp>& __x, const _Up& __y)
                                                     ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:415:5: note: previous declaration ‘namespace std { }::pow’
     pow(_Tp __x, _Up __y)
     ^~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1872:53: error: ‘std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type> ralgo::pow(const _Tp&, const std::complex<_Up>&)’ conflicts with a previous declaration
     pow(const _Tp& __x, const std::complex<_Up>& __y)
                                                     ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:415:5: note: previous declaration ‘namespace std { }::pow’
     pow(_Tp __x, _Up __y)
     ^~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex:1880:67: error: ‘std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type> ralgo::pow(const std::complex<_Tp>&, const std::complex<_Up>&)’ conflicts with a previous declaration
     pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
                                                                   ^
In file included from /usr/include/x86_64-linux-gnu/qt5/QtCore/qmath.h:55:0,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCore/QtCore:99,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtChartsDepends:3,
                 from /usr/include/x86_64-linux-gnu/qt5/QtCharts/QtCharts:3,
                 from /home/mirmik/project/ralgraph/./ralgraph/chart.h:7,
                 from ./main.cpp:2:
/usr/include/c++/7/cmath:415:5: note: previous declaration ‘namespace std { }::pow’
     pow(_Tp __x, _Up __y)
     ^~~
In file included from /home/mirmik/project/ralgo/./ralgo/util/helpers.h:6:0,
                 from /home/mirmik/project/ralgo/./ralgo/vecops.h:7,
                 from ./main.cpp:6:
/usr/include/c++/7/complex: In function ‘__complex__ float ralgo::__complex_proj(__complex__ float)’:
/usr/include/c++/7/complex:1904:39: error: ‘__complex__ float ralgo::__complex_proj(__complex__ float)’ conflicts with a previous declaration
   __complex_proj(__complex__ float __z)
                                       ^
/usr/include/c++/7/complex:1893:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_proj(const std::complex<_Tp>&)’
     __complex_proj(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ double ralgo::__complex_proj(__complex__ double)’:
/usr/include/c++/7/complex:1908:40: error: ‘__complex__ double ralgo::__complex_proj(__complex__ double)’ conflicts with a previous declaration
   __complex_proj(__complex__ double __z)
                                        ^
/usr/include/c++/7/complex:1893:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_proj(const std::complex<_Tp>&)’
     __complex_proj(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: In function ‘__complex__ long double ralgo::__complex_proj(const __complex__ long double&)’:
/usr/include/c++/7/complex:1912:52: error: ‘__complex__ long double ralgo::__complex_proj(const __complex__ long double&)’ conflicts with a previous declaration
   __complex_proj(const __complex__ long double& __z)
                                                    ^
/usr/include/c++/7/complex:1893:5: note: previous declaration ‘std::complex<_Tp> ralgo::__complex_proj(const std::complex<_Tp>&)’
     __complex_proj(const std::complex<_Tp>& __z)
     ^~~~~~~~~~~~~~
/usr/include/c++/7/complex: At global scope:
/usr/include/c++/7/complex:1917:38: error: ‘std::complex<_Tp> ralgo::proj(const std::complex<_Tp>&)’ conflicts with a previous declaration
     proj(const std::complex<_Tp>& __z)
                                      ^
/usr/include/c++/7/complex:1889:44: note: previous declaration ‘std::complex<_Tp> ralgo::proj(const std::complex<_Tp>&)’
   template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);
                                            ^~~~
/usr/include/c++/7/complex:1928:17: error: ‘std::complex<typename __gnu_cxx::__promote<_Tp>::__type> ralgo::proj(_Tp)’ conflicts with a previous declaration
     proj(_Tp __x)
                 ^
/usr/include/c++/7/complex:1889:44: note: previous declaration ‘std::complex<_Tp> ralgo::proj(const std::complex<_Tp>&)’
   template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);
                                            ^~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<float> ralgo::operator""if(long double)’:
/usr/include/c++/7/complex:1953:33: error: return type ‘class std::complex<float>’ is incomplete
   operator""if(long double __num)
                                 ^
/usr/include/c++/7/complex:1954:63: error: too many initializers for ‘std::complex<float>’
   { return std::complex<float>{0.0F, static_cast<float>(__num)}; }
                                                               ^
/usr/include/c++/7/complex:1954:63: error: invalid use of incomplete type ‘class std::complex<float>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<float>’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<float> ralgo::operator""if(long long unsigned int)’:
/usr/include/c++/7/complex:1957:40: error: return type ‘class std::complex<float>’ is incomplete
   operator""if(unsigned long long __num)
                                        ^
/usr/include/c++/7/complex:1957:40: error: ‘constexpr void ralgo::operator""if(long long unsigned int)’ conflicts with a previous declaration
/usr/include/c++/7/complex:1953:3: note: previous declaration ‘constexpr void ralgo::operator""if(long double)’
   operator""if(long double __num)
   ^~~~~~~~
/usr/include/c++/7/complex:1958:63: error: too many initializers for ‘std::complex<float>’
   { return std::complex<float>{0.0F, static_cast<float>(__num)}; }
                                                               ^
/usr/include/c++/7/complex:1958:63: error: invalid use of incomplete type ‘class std::complex<float>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<float>’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<double> ralgo::operator""i(long double)’:
/usr/include/c++/7/complex:1961:32: error: return type ‘class std::complex<double>’ is incomplete
   operator""i(long double __num)
                                ^
/usr/include/c++/7/complex:1962:64: error: too many initializers for ‘std::complex<double>’
   { return std::complex<double>{0.0, static_cast<double>(__num)}; }
                                                                ^
/usr/include/c++/7/complex:1962:64: error: invalid use of incomplete type ‘class std::complex<double>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<double>’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<double> ralgo::operator""i(long long unsigned int)’:
/usr/include/c++/7/complex:1965:39: error: return type ‘class std::complex<double>’ is incomplete
   operator""i(unsigned long long __num)
                                       ^
/usr/include/c++/7/complex:1965:39: error: ‘constexpr void ralgo::operator""i(long long unsigned int)’ conflicts with a previous declaration
/usr/include/c++/7/complex:1961:3: note: previous declaration ‘constexpr void ralgo::operator""i(long double)’
   operator""i(long double __num)
   ^~~~~~~~
/usr/include/c++/7/complex:1966:64: error: too many initializers for ‘std::complex<double>’
   { return std::complex<double>{0.0, static_cast<double>(__num)}; }
                                                                ^
/usr/include/c++/7/complex:1966:64: error: invalid use of incomplete type ‘class std::complex<double>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<double>’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<long double> ralgo::operator""il(long double)’:
/usr/include/c++/7/complex:1969:33: error: return type ‘class std::complex<long double>’ is incomplete
   operator""il(long double __num)
                                 ^
/usr/include/c++/7/complex:1970:49: error: too many initializers for ‘std::complex<long double>’
   { return std::complex<long double>{0.0L, __num}; }
                                                 ^
/usr/include/c++/7/complex:1970:49: error: invalid use of incomplete type ‘class std::complex<long double>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<long double>’
   template<typename _Tp> class complex;
                                ^~~~~~~
/usr/include/c++/7/complex: In function ‘constexpr std::complex<long double> ralgo::operator""il(long long unsigned int)’:
/usr/include/c++/7/complex:1973:40: error: return type ‘class std::complex<long double>’ is incomplete
   operator""il(unsigned long long __num)
                                        ^
/usr/include/c++/7/complex:1973:40: error: ‘constexpr void ralgo::operator""il(long long unsigned int)’ conflicts with a previous declaration
/usr/include/c++/7/complex:1969:3: note: previous declaration ‘constexpr void ralgo::operator""il(long double)’
   operator""il(long double __num)
   ^~~~~~~~
/usr/include/c++/7/complex:1974:75: error: too many initializers for ‘std::complex<long double>’
   { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }
                                                                           ^
/usr/include/c++/7/complex:1974:75: error: invalid use of incomplete type ‘class std::complex<long double>’
/usr/include/c++/7/complex:63:32: note: declaration of ‘class std::complex<long double>’
   template<typename _Tp> class complex;
                                ^~~~~~~
In file included from ./main.cpp:6:0:
/home/mirmik/project/ralgo/./ralgo/vecops.h: At global scope:
/home/mirmik/project/ralgo/./ralgo/vecops.h:45:23: error: ‘auto ralgo::arange(int)’ conflicts with a previous declaration
   auto arange(int stop)
                       ^
/home/mirmik/project/ralgo/./ralgo/vecops.h:33:8: note: previous declaration ‘auto ralgo::arange(int, int, int)’
   auto arange(int start, int stop, int step)
        ^~~~~~
In file included from ./main.cpp:6:0:
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘constexpr auto ralgo::vectorize(const F&, Args&& ...)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:105:34: error: definition of ‘auto ralgo::vectorize(const F&, Args&& ...)::<lambda>::operator()(const V&) const’ is not in namespace enclosing ‘ralgo::vectorize(const F&, Args&& ...)::<lambda>’ [-fpermissive]
    auto lamda = [=](const V & vec){ return elementwise<R>(f, vec, args...); };
                                  ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In lambda function:
/home/mirmik/project/ralgo/./ralgo/vecops.h:105:44: error: ‘elementwise’ was not declared in this scope
    auto lamda = [=](const V & vec){ return elementwise<R>(f, vec, args...); };
                                            ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:105:44: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:105:57: error: expected primary-expression before ‘>’ token
    auto lamda = [=](const V & vec){ return elementwise<R>(f, vec, args...); };
                                                         ^
/home/mirmik/project/ralgo/./ralgo/vecops.h:105:74: error: expected binary operator before ‘)’ token
    auto lamda = [=](const V & vec){ return elementwise<R>(f, vec, args...); };
                                                                          ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::abs(const A&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:109:78: error: ‘elementwise’ was not declared in this scope
   template <class R=void, class A> defsame_t<R,A> abs(const A& obj) { return elementwise<R>(ralgo::op::abs(), obj); }
                                                                              ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:109:78: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:109:91: error: expected primary-expression before ‘>’ token
   template <class R=void, class A> defsame_t<R,A> abs(const A& obj) { return elementwise<R>(ralgo::op::abs(), obj); }
                                                                                           ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘auto ralgo::real(const V<T>&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:110:85: error: ‘elementwise’ was not declared in this scope
   template <template<class C> class V, class T> auto real(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.real();}, obj); }
                                                                                     ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:110:85: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:110:100: error: expected primary-expression before ‘>’ token
   template <template<class C> class V, class T> auto real(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.real();}, obj); }
                                                                                                    ^~
/home/mirmik/project/ralgo/./ralgo/vecops.h:110:120: error: definition of ‘auto ralgo::real(const V<T>&)::<lambda>::operator()(const auto:1&) const’ is not in namespace enclosing ‘ralgo::real(const V<T>&)::<lambda>’ [-fpermissive]
   template <template<class C> class V, class T> auto real(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.real();}, obj); }
                                                                                                                        ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘auto ralgo::imag(const V<T>&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:111:85: error: ‘elementwise’ was not declared in this scope
   template <template<class C> class V, class T> auto imag(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.imag();}, obj); }
                                                                                     ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:111:85: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:111:100: error: expected primary-expression before ‘>’ token
   template <template<class C> class V, class T> auto imag(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.imag();}, obj); }
                                                                                                    ^~
/home/mirmik/project/ralgo/./ralgo/vecops.h:111:120: error: definition of ‘auto ralgo::imag(const V<T>&)::<lambda>::operator()(const auto:2&) const’ is not in namespace enclosing ‘ralgo::imag(const V<T>&)::<lambda>’ [-fpermissive]
   template <template<class C> class V, class T> auto imag(const V<T>& obj) { return elementwise<V<T>>([](const auto & c) {return c.imag();}, obj); }
                                                                                                                        ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::add_vs(const A&, B)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:152:93: error: ‘elementwise’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> add_vs(const A& a, B b) { return elementwise<R>(ralgo::op::add(), a, b); }
                                                                                             ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:152:93: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:152:106: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> add_vs(const A& a, B b) { return elementwise<R>(ralgo::op::add(), a, b); }
                                                                                                          ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::sub_vs(const A&, B)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:153:93: error: ‘elementwise’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> sub_vs(const A& a, B b) { return elementwise<R>(ralgo::op::sub(), a, b); }
                                                                                             ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:153:93: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:153:106: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> sub_vs(const A& a, B b) { return elementwise<R>(ralgo::op::sub(), a, b); }
                                                                                                          ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::mul_vs(const A&, B)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:154:93: error: ‘elementwise’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> mul_vs(const A& a, B b) { return elementwise<R>(ralgo::op::mul(), a, b); }
                                                                                             ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:154:93: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:154:106: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> mul_vs(const A& a, B b) { return elementwise<R>(ralgo::op::mul(), a, b); }
                                                                                                          ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::div_vs(const A&, B)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:155:93: error: ‘elementwise’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> div_vs(const A& a, B b) { return elementwise<R>(ralgo::op::div(), a, b); }
                                                                                             ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:155:93: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:71:18: note:   ‘ralgo::elementwise’
   defsame_t<R,A> elementwise(const F& f, const A & a, Args&& ... args)
                  ^~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:155:106: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> div_vs(const A& a, B b) { return elementwise<R>(ralgo::op::div(), a, b); }
                                                                                                          ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::add_vv(const A&, const B&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:157:100: error: ‘elementwise2’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> add_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::add(), a, b); }
                                                                                                    ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:157:100: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:86:5: note:   ‘ralgo::elementwise2’
   R elementwise2(const F& f, const A& a, const B& b, Args&& ... args)
     ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:157:114: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> add_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::add(), a, b); }
                                                                                                                  ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::sub_vv(const A&, const B&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:158:100: error: ‘elementwise2’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> sub_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::sub(), a, b); }
                                                                                                    ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:158:100: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:86:5: note:   ‘ralgo::elementwise2’
   R elementwise2(const F& f, const A& a, const B& b, Args&& ... args)
     ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:158:114: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> sub_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::sub(), a, b); }
                                                                                                                  ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::mul_vv(const A&, const B&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:159:100: error: ‘elementwise2’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> mul_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::mul(), a, b); }
                                                                                                    ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:159:100: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:86:5: note:   ‘ralgo::elementwise2’
   R elementwise2(const F& f, const A& a, const B& b, Args&& ... args)
     ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:159:114: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> mul_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::mul(), a, b); }
                                                                                                                  ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: In function ‘ralgo::defsame_t<R, A> ralgo::div_vv(const A&, const B&)’:
/home/mirmik/project/ralgo/./ralgo/vecops.h:160:100: error: ‘elementwise2’ was not declared in this scope
   template <class R=void, class A, class B> defsame_t<R,A> div_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::div(), a, b); }
                                                                                                    ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:160:100: note: suggested alternative:
/home/mirmik/project/ralgo/./ralgo/vecops.h:86:5: note:   ‘ralgo::elementwise2’
   R elementwise2(const F& f, const A& a, const B& b, Args&& ... args)
     ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:160:114: error: expected primary-expression before ‘>’ token
   template <class R=void, class A, class B> defsame_t<R,A> div_vv(const A& a, const B& b) { return elementwise2<R>(ralgo::op::div(), a, b); }
                                                                                                                  ^
/home/mirmik/project/ralgo/./ralgo/vecops.h: At global scope:
/home/mirmik/project/ralgo/./ralgo/vecops.h:210:80: error: ‘void ralgo::merge_sorted(const V&, const W&, R, double, double)’ conflicts with a previous declaration
   void merge_sorted(const V& v, const W& w, R writer, double start, double stop)
                                                                                ^
/home/mirmik/project/ralgo/./ralgo/vecops.h:195:8: note: previous declaration ‘void ralgo::merge_sorted(VI, VI, WI, WI, RI)’
   void merge_sorted(VI vit, const VI vend, WI wit, const WI wend, RI rit)
        ^~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/vecops.h:221:70: error: ‘auto ralgo::merge_sorted(const V&, const W&, double, double)’ conflicts with a previous declaration
   auto merge_sorted(const V& v, const W& w, double start, double stop)
                                                                      ^
/home/mirmik/project/ralgo/./ralgo/vecops.h:195:8: note: previous declaration ‘void ralgo::merge_sorted(VI, VI, WI, WI, RI)’
   void merge_sorted(VI vit, const VI vend, WI wit, const WI wend, RI rit)
        ^~~~~~~~~~~~
./main.cpp: In function ‘int ralgo::main()’:
./main.cpp:10:22: error: variable ‘rabbit::pnt2<float> cp’ has initializer but incomplete type
  rabbit::pnt2<float> cp = rabbit::pnt2<float>(8,3);
                      ^~
./main.cpp:10:50: error: invalid use of incomplete type ‘class rabbit::pnt2<float>’
  rabbit::pnt2<float> cp = rabbit::pnt2<float>(8,3);
                                                  ^
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/linalg.h:9:27: note: declaration of ‘class rabbit::pnt2<float>’
  template <class T> class pnt2;
                           ^~~~
./main.cpp:11:35: error: invalid use of incomplete type ‘class rabbit::vec2<float>’
  auto xp = rabbit::vec2<float>(1,4);
                                   ^
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/linalg.h:10:27: note: declaration of ‘class rabbit::vec2<float>’
  template <class T> class vec2;
                           ^~~~
./main.cpp:12:35: error: invalid use of incomplete type ‘class rabbit::vec2<float>’
  auto yp = rabbit::vec2<float>(0,5);
                                   ^
In file included from /home/mirmik/project/rabbit/./rabbit/geom/curve2.h:4:0,
                 from /home/mirmik/project/ralgo/./ralgo/planning/multiax.h:6,
                 from ./main.cpp:3:
/home/mirmik/project/rabbit/./rabbit/linalg.h:10:27: note: declaration of ‘class rabbit::vec2<float>’
  template <class T> class vec2;
                           ^~~~
./main.cpp:14:40: error: variable ‘rabbit::ellipse_curve2<float> basecrv’ has initializer but incomplete type
  rabbit::ellipse_curve2<float> basecrv(cp,xp,yp);
                                        ^~
./main.cpp:15:32: error: variable ‘rabbit::trimmed_curve2<float> crv’ has initializer but incomplete type
  rabbit::trimmed_curve2<float> crv{ &basecrv, 0, 1 };
                                ^~~
./main.cpp:28:33: error: no matching function for call to ‘ralgo::geom2d_trajectory<>::inloctime_placed(__gnu_cxx::__alloc_traits<std::allocator<float> >::value_type&, ralgo::phase<> [2])’
   traj.inloctime_placed(t[i],phs);
                                 ^
In file included from ./main.cpp:3:0:
/home/mirmik/project/ralgo/./ralgo/planning/multiax.h:66:7: note: candidate: int ralgo::geom2d_trajectory<P, V, A, T>::inloctime_placed(T, ralgo::phase<P, V, A>*) [with P = long int; V = float; A = float; T = long int]
   int inloctime_placed(T time, phase<P, V, A> *phs)
       ^~~~~~~~~~~~~~~~
/home/mirmik/project/ralgo/./ralgo/planning/multiax.h:66:7: note:   no known conversion for argument 2 from ‘ralgo::phase<> [2]’ to ‘ralgo::phase<long int, float, float>*’
